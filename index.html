<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="Intro.css">
    </link>
    <script src="Intro.js"></script>
    <title>ç³»ç»ŸåŒ–è®¾è®¡</title>
    <style>
        body,
        html {
            overflow: hidden;
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f7fa;
            touch-action: none;
            /* ç¦ç”¨æµè§ˆå™¨é»˜è®¤çš„è§¦æ‘¸è¡Œä¸ºï¼Œä»¥ä¾¿å¤„ç†åŒæŒ‡ç¼©æ”¾ */
            background-image: radial-gradient(circle, #d0d0d0 1px, transparent 1px);
            background-size: 30px 30px;
            /* åˆå§‹ç½‘æ ¼å¤§å° */
            background-position: center center;
        }

        [contenteditable="true"]:focus {
            outline: none;
        }

        .no-label .MultiCard {
            text-align: left;
            display: flex;
            padding: 6px;
            gap: 4px;
            /* border-bottom: 1px solid #cccccc; */
            flex-wrap: wrap;
            flex-direction: column;
            align-items: baseline;
            border-bottom: 1px solid #cccccc3b;
        }

        .no-label:last-child .MultiCard {
            border-bottom: 0
        }

        /* æ ‡ç­¾å®¹å™¨ */
        .label-container {
            position: absolute;
            top: -10px;
            /* å¾®è°ƒä½ç½®ï¼Œä½¿å…¶éƒ¨åˆ†åœ¨å¡ç‰‡å¤–éƒ¨ */
            right: -10px;
            /* å¾®è°ƒä½ç½®ï¼Œä½¿å…¶éƒ¨åˆ†åœ¨å¡ç‰‡å¤–éƒ¨ */
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* åœ†å½¢æ ‡ç­¾æ ·å¼ */
        .circle-label {
            width: 100%;
            height: 100%;
            background-color: #cccccc;
            /* ç°è‰²èƒŒæ™¯ */
            color: #ffffff;
            /* ç™½è‰²æ–‡å­— */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            /* å¢åŠ ä¸€ç‚¹é˜´å½± */
            z-index: 1;
            /* ç¡®ä¿æ ‡ç­¾åœ¨å¡ç‰‡å†…å®¹ä¹‹ä¸Š */
        }

        .folded-corner-card {
            position: relative;
            width: 200px;
            height: 200px;
            background-color: aliceblue;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            flex-direction: column;
            align-content: center;
        }

        /* ç°è‰²æ–¹æ¡†ï¼Œä½äºæŠ˜è§’ä¸‹æ–¹ */
        .folded-corner-card::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            /* æ–¹æ¡†å¤§å°ä¸æŠ˜è§’ä¸‰è§’å½¢åŒ¹é… */
            width: 30px;
            height: 30px;
            /* ç°è‰²èƒŒæ™¯ */
            background-color: #cccccc;
            /* ç¡®ä¿å®ƒåœ¨å†…å®¹å’ŒæŠ˜è§’ä¹‹ä¸‹ */
            z-index: 0;
        }

        /* ä½¿ç”¨ä¼ªå…ƒç´ åˆ›å»ºæŠ˜è§’ä¸‰è§’å½¢ */
        .folded-corner-card::before {
            content: '';
            position: absolute;
            /* å®šä½åœ¨å³ä¸‹è§’ */
            bottom: 0;
            right: 0;
            /* ä½¿ç”¨è¾¹æ¡†æŠ€å·§åˆ›å»ºä¸‰è§’å½¢ */
            width: 0;
            height: 0;
            border-style: solid;
            /* è°ƒæ•´è¾¹æ¡†å®½åº¦æ”¹å˜ä¸‰è§’å½¢å¤§å° */
            border-width: 30px 30px 0 0;
            /* ä¸Šè¾¹æ¡†ä¸ºå¡ç‰‡èƒŒæ™¯è‰²ï¼ˆç™½è‰²ï¼‰ï¼Œæ¨¡æ‹Ÿå‘å†…æŠ˜å  */
            border-color: #ffffff transparent transparent transparent;
            /* ç¡®ä¿å®ƒåœ¨å†…å®¹å’Œç°è‰²æ–¹æ¡†ä¹‹ä¸Š */
            z-index: 1;
        }

        #toolbar {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 12px 20px;
            border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            display: flex;
            gap: 15px;
            backdrop-filter: blur(5px);
        }

        .toolbar-btn {
            padding: 10px 20px;
            background-color: #1890ff;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .toolbar-btn:hover {
            background-color: #40a9ff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .toolbar-btn:active {
            transform: translateY(0);
        }

        #trash-can {
            width: 40px;
            height: 40px;
            background-color: #ff4d6b;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
            position: relative;
            z-index: 1001;
        }

        #trash-can:hover {
            background-color: #ff7875;
            transform: scale(1.1);
        }

        #trash-can::before {
            content: "ğŸ—‘ï¸";
            font-size: 20px;
        }

        #trash-can.active {
            background-color: #ff7875;
            transform: scale(1.2);
        }


        #add-node-btn,
        #reset-view-btn,
        #trash-can-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
            position: relative;
            z-index: 1001;
            border: none;
            padding: 0;
        }

        #add-node-btn:hover {
            background-color: #40a9ff;
            transform: scale(1.1);
        }

        #add-node-btn:active {
            transform: scale(1.2);
        }

        #add-node-btn {
            background-color: #1890ff;
        }

        #reset-view-btn {
            background-color: #1890ff;
        }

        #reset-view-btn:hover {
            background-color: #1890ff;
            transform: scale(1.1);
        }

        #reset-view-btn:active {
            transform: scale(1.2);
        }

        #trash-can-btn {
            background-color: #ff4d6b;
        }

        #trash-can-btn:hover {
            background-color: #ff7875;
            transform: scale(1.1);
        }

        #trash-can-btn:active {
            transform: scale(1.2);
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: grab;
            transform-origin: 50% 50%;
            /* éšè—æ»šåŠ¨æ¡ä½†ä¿æŒåŠŸèƒ½ */
            scrollbar-width: none;
            /* Firefox */
        }

        /* Webkitæµè§ˆå™¨éšè—æ»šåŠ¨æ¡ */
        #canvas-container::-webkit-scrollbar {
            display: none;
        }

        #canvas-container.dragging {
            cursor: grabbing;
        }

        .node {
            position: absolute;
            min-width: 130px;
            min-height: 70px;
            padding: 15px;
            box-sizing: border-box;
            background-color: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 18px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
            user-select: none;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            word-break: break-word;
            overflow-wrap: break-word;
            transition: box-shadow 0.2s, border-color 0.2s, opacity 0.3s;
            z-index: 10;
            transform-origin: center center;
            /* ç¼©æ”¾ä¸­å¿ƒç‚¹ */
        }

        /* æ·»åŠ æ— æ ‡ç­¾ç‚¹çš„æ ·å¼ */
        .no-label {
            min-width: 20px;
            min-height: 20px;
            padding: 0;
            border-radius: 50%;
            list-style: none;
            list-style-type: none;
        }

        .node.no-label::before {
            content: "";
            display: block;
            width: 10px;
            height: 10px;
            background-color: #1890ff;
            border-radius: 50%;
        }

        .node.locked {
            background-color: #f0f5ff;
            /* é”å®šèŠ‚ç‚¹çš„ç‰¹æ®ŠèƒŒæ™¯è‰² */
            border: 2px dashed #1890ff;
            /* é”å®šèŠ‚ç‚¹çš„ç‰¹æ®Šè¾¹æ¡† */
        }

        .node.locked::after {
            content: "ğŸ”’";
            position: absolute;
            top: -10px;
            right: -10px;
            font-size: 16px;
        }

        .node:hover {
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.12);
            border-color: #d1d5da;
        }

        .node.dragging {
            cursor: grabbing;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.18);
            z-index: 1000 !important;
            /* ç¡®ä¿æ‹–æ‹½æ—¶å§‹ç»ˆç½®é¡¶ */
        }

        .node.editing {
            cursor: text;
            border-color: #1890ff;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
            z-index: 1000;
        }

        .node.editing textarea {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            resize: none;
            background: transparent;
            font-family: inherit;
            font-size: 16px;
            text-align: inherit;
            overflow: hidden;
        }

        .node.overlapping {
            opacity: 0.5;
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            z-index: 1000;
            max-width: 320px;
            backdrop-filter: blur(5px);
        }

        .instructions h3 {
            margin: 0 0 10px 0;
            color: #2d3748;
            font-size: 16px;
        }

        .instructions ul {
            padding-left: 20px;
            margin: 0;
        }

        .instructions li {
            margin-bottom: 7px;
            color: #4a5568;
        }

        .api-call-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            background-color: #fffbe6;
            border: 1px solid #ffe58f;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            color: #d48806;
            z-index: 1002;
            display: none;
        }

        .api-call-indicator-Failed {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            background-color: #ff8f8f;
            border: 1px solid #ffe58f;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            color: #d48806;
            z-index: 1002;
            display: none;
        }
    </style>
    <style>
        /* è‡ªå®šä¹‰ä¸»é¢˜æ ·å¼ */
        .custom-intro-tooltip {
            border-radius: 20px;
            padding: 0px 6px !important;
            /* margin-top: 20px !important; */
            font-size: 14px;
            line-height: 1.6;
            max-width: 400px;
            min-width: 320px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            background: #fff;
            color: #333;
            border: 1px solid #eee;
            animation: fadeIn 0.4s ease-out;
            transition: all 0.3s ease;
        }

        .custom-intro-tooltip .introjs-arrow {
            background: #fff;
            border: 1px solid #eee;
            animation: pulse 1.5s infinite;
        }

        .custom-intro-button {
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            background: #f0f2f5;
            color: #333;
            border: none;
        }

        .custom-intro-button:hover {
            background: #4a6cf7;
            color: white;
            transform: translateY(-1px);
        }


        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 0, 0, 0.3);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(0, 0, 0, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(0, 0, 0, 0);
            }
        }

        .introjs-tooltip-header {
            display: none;
        }

        .introjs-tooltiptext {
            padding: 15px 20px 0px 20px !important;
        }

        video {
            width: 280px;
            height: auto;
            border-radius: 20px;
            margin-top: 10px;
        }

        .introjs-bullets,
        .introjs-helperNumberLayer {
            padding: 0 !important;
            margin: 2px !important;
        }

        @media screen and (max-height: 600px) {
            video {
                display: none;
            }

            .introjs-bullets,
            .introjs-helperNumberLayer {
                padding: 0;
                margin: 2px;
            }
        }
    </style>
    <style>
        /* ä¾§è¾¹æ æ ·å¼ */
        #sidebar {
            position: fixed;
            right: 0;
            top: 0;
            /* width: 250px; */
            height: 100vh;
            overflow-y:scroll;
            background-color: white;
            color: #333;
            z-index: 1000;
            padding: 20px 10px;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
        }

        #sidebar h2 {
            text-align: center;
            margin-top: 0;
            font-size: 1.4em;
        }

        .sidebar-item {
            background-color: #f0f5ff;
            /* é”å®šèŠ‚ç‚¹çš„ç‰¹æ®ŠèƒŒæ™¯è‰² */
            border: 2px dashed #1890ff;
            /* é”å®šèŠ‚ç‚¹çš„ç‰¹æ®Šè¾¹æ¡† */
            color: #333;
            margin: 10px 0;
        }

        .sidebar-item::after {
            content: "ğŸ”’";
            position: absolute;
            top: -10px;
            right: -10px;
            font-size: 16px;
        }

        .sidebar-item:hover {
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.12);
            border-color: #d1d5da;
        }

        .sidebar-item:active {
            cursor: grabbing;
        }

        .sidebar-item.dragging {
            opacity: 0.7;
        }
    </style>
    <style>
        #custom-node-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            padding: 20px;
            z-index: 1003;
            width: 300px;
            display: none;
        }

        #custom-node-dialog h3 {
            margin-top: 0;
            text-align: center;
        }

        #custom-node-dialog label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        #custom-node-dialog input,
        #custom-node-dialog textarea {
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        #custom-node-dialog textarea {
            height: 80px;
            resize: vertical;
        }

        #custom-node-dialog .buttons {
            text-align: right;
        }

        #custom-node-dialog button {
            padding: 8px 15px;
            margin-left: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #custom-node-dialog #confirm-custom-node {
            background-color: #1890ff;
            color: white;
        }

        #custom-node-dialog #cancel-custom-node {
            background-color: #f0f0f0;
            color: #333;
        }

        #custom-node-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1002;
            display: none;
        }
    </style>
</head>

<body>
    <div id="toolbar">
        <button id="add-node-btn" class="toolbar-btn" style="font-size: 24px;">+</button>
        <button id="reset-view-btn" class="toolbar-btn" style="font-size: 20px;">â—</button>
        <button id="trash-can-btn" class="toolbar-btn" style="font-size: 24px;"><span
                style="margin-top: -2px;">â™²</span></button>
        <!-- åºŸå¼ƒå›¾æ ‡ ğŸ¯ ğŸ§­ ğŸ“ ğŸ—‘-->
        <!-- <button id="add-locked-node-btn" class="toolbar-btn">æ·»åŠ é”å®šèŠ‚ç‚¹</button> -->
        <!-- <div id="trash-can"></div> -->
    </div>
    <!-- æ·»åŠ ä¾§è¾¹æ  -->
    <div id="sidebar">
        <h2>èŠ‚ç‚¹æ¨¡æ¿åº“</h2>
        <div class="node sidebar-item" style="position: relative;" draggable="true" data-content="ç”¨æˆ·ç”»åƒ">ç”¨æˆ·ç”»åƒ</div>
        <div class="node sidebar-item" style="position: relative;" draggable="true" data-content="ç«å“åˆ†æ">ç«å“åˆ†æ</div>
        <div class="node sidebar-item" style="position: relative;" draggable="true" data-content="SWOTåˆ†æ">SWOTåˆ†æ</div>
        <div class="node sidebar-item" style="position: relative;" draggable="true" data-content="PESTåˆ†æ">PESTåˆ†æ</div>
        <div class="node sidebar-item" style="position: relative;" draggable="true" data-content="5W2Håˆ†æ">5W2Håˆ†æ</div>
        <div class="node sidebar-item" style="position: relative;" draggable="true" data-content="STPæˆ˜ç•¥">STPæˆ˜ç•¥</div>
        <div class="node sidebar-item" style="position: relative;" draggable="true" data-content="CMFè®¾è®¡">CMFè®¾è®¡</div>
        <div class="node sidebar-item" style="position: relative;" draggable="true" data-content="æ–°å…´æŠ€æœ¯">æ–°å…´æŠ€æœ¯</div>
        <div class="node sidebar-item" style="position: relative;" draggable="true" data-content="ç”¨æˆ·ä½“éªŒ">ç”¨æˆ·ä½“éªŒ</div>
        <div class="node sidebar-item" style="position: relative;" draggable="true" data-content="å•†ä¸šæ¨¡å¼">å•†ä¸šæ¨¡å¼</div>
    </div>
    <div class="instructions">
        <h3>æ“ä½œè¯´æ˜</h3>
        <ul>
            <li><strong>æ·»åŠ èŠ‚ç‚¹:</strong> ç‚¹å‡» "+" æŒ‰é’®</li>
            <!-- <li><strong>æ·»åŠ é”å®šèŠ‚ç‚¹:</strong> ç‚¹å‡» "æ·»åŠ é”å®šèŠ‚ç‚¹" æŒ‰é’®</li> -->
            <li><strong>ç¼–è¾‘æ–‡å­—:</strong> åŒå‡»èŠ‚ç‚¹</li>
            <li><strong>æ‹–åŠ¨èŠ‚ç‚¹/ç”»å¸ƒ:</strong> æŒ‰ä½å¹¶æ‹–åŠ¨</li>
            <li><strong>ç¼©æ”¾ç”»å¸ƒ:</strong> é¼ æ ‡æ»šè½® / æ‰‹æœºç«¯åŒæŒ‡æåˆ</li>
            <li><strong>è¿”å›ä¸­å¿ƒ:</strong> ç‚¹å‡» "â—" æŒ‰é’®</li>
            <li><strong>é‡å äº¤äº’:</strong> æ‹–åŠ¨èŠ‚ç‚¹ä½¿å…¶90%é‡å ï¼Œ<strong>æ¾å¼€</strong>åè§¦å‘æ€è€ƒå¹¶ç”Ÿæˆæ–°Idea</li>
            <li><strong>åˆ é™¤èŠ‚ç‚¹:</strong> å°†èŠ‚ç‚¹æ‹–æ‹½åˆ° "â™²" ä¸Š (é”å®šèŠ‚ç‚¹é™¤å¤–)</li>
        </ul>
    </div>
    <div id="api-call-indicator" class="api-call-indicator">å—ç¥æ€è€ƒä¸­...</div>
    <div id="api-call-indicator-Failed" class="api-call-indicator-Failed">å—ç¥æ€ç»ªè¢«æ‰“ä¹±äº†(Ë‡ËË‡)...</div>
    <div id="canvas-container"></div>
    <script>
        // æ–°æ‰‹æ•™ç¨‹å¼•å¯¼å˜é‡
        let guaid1 = 0;
        let guaid2 = 0;
        let guaid3 = 0;
        let guaid4 = 0;
        let guaid5 = 0;

        // æ–°æ‰‹æ•™ç¨‹
        let beautyIntro;
        function OnceIntro(element, intro, position) {
            if (!localStorage.getItem('introjs-dontShowAgain')) {
                const Intro = introJs.tour()
                return Intro.setOptions({
                    nextLabel: 'æ˜ç™½',
                    prevLabel: 'æ˜ç™½',
                    skipLabel: '',
                    doneLabel: 'æ˜ç™½',
                    // showStepNumbers: true,
                    hidePrev: true,
                    // hideNext: true,
                    showBullets: false,
                    showProgress: false,
                    // showButtons: false,
                    overlayOpacity: 0.75,
                    tooltipClass: 'custom-intro-tooltip',
                    buttonClass: 'custom-intro-button',
                    highlightClass: 'custom-intro-highlight',
                    animate: true,
                    // æ·»åŠ è‡ªå®šä¹‰ä¸»é¢˜
                    theme: 'custom-theme',
                    // helperElementPadding: 0,      // è¾…åŠ©å…ƒç´ çš„å†…è¾¹è·
                    // overlayOpacity: 0.5,          // é®ç½©å±‚ä¸é€æ˜åº¦
                    // äº¤äº’è¡Œä¸º
                    exitOnEsc: false,  // ç¦ç”¨ESCé€€å‡º

                    keyboardNavigation: true,
                })
                    .addSteps([
                        {
                            element: element,
                            intro: intro,
                            position: position
                        }
                    ])
                // .oncomplete(
                //     function () {
                //         // æ·»åŠ ä¸€ä¸ªCookieï¼Œè¡¨ç¤ºç”¨æˆ·å·²ç»å®Œæˆå¼•å¯¼
                //         localStorage.setItem('introjs-dontShowAgain', 1);
                //     }
                // )
            }
        }
        function MultiIntro(elements) {
            if (!localStorage.getItem('introjs-dontShowAgain')) {
                const Intro = introJs.tour()
                return Intro.setOptions({
                    nextLabel: 'æ˜ç™½',
                    prevLabel: 'ä¸Šä¸€æ­¥',
                    skipLabel: '',
                    doneLabel: 'æ˜ç™½',
                    showStepNumbers: true,
                    hidePrev: true,
                    showBullets: true,
                    overlayOpacity: 0.75,
                    tooltipClass: 'custom-intro-tooltip',
                    buttonClass: 'custom-intro-button',
                    highlightClass: 'custom-intro-highlight',
                    animate: true,
                    // æ·»åŠ è‡ªå®šä¹‰ä¸»é¢˜
                    theme: 'custom-theme',
                    // helperElementPadding: 0,      // è¾…åŠ©å…ƒç´ çš„å†…è¾¹è·
                    // // äº¤äº’è¡Œä¸º
                    exitOnEsc: false,  // ç¦ç”¨ESCé€€å‡º
                    keyboardNavigation: true,
                    // ç•Œé¢æ˜¾ç¤º
                    stepNumbersOfLabel: "/",
                })
                    .addSteps(elements)
            }
        }
        // ç›‘å¬æ•´ä¸ªæ–‡æ¡£çš„ç‚¹å‡»äº‹ä»¶
        // document.addEventListener('click', function (event) {
        //     // è·å–ç‚¹å‡»ä½ç½®çš„å…ƒç´ 
        //     const clickedElement = document.elementFromPoint(event.clientX, event.clientY);

        //     // è·å–å¹¶æ˜¾ç¤ºå…ƒç´ çš„ä¿¡æ¯
        //     console.log('ç‚¹å‡»çš„å…ƒç´ :', clickedElement);
        //     console.log('å…ƒç´ æ ‡ç­¾å:', clickedElement.tagName);
        //     console.log('å…ƒç´ ç±»å:', clickedElement.className);
        //     console.log('å…ƒç´ ID:', clickedElement.id);

        //     // å¯ä»¥æ·»åŠ æ›´å¤šæ“ä½œï¼Œå¦‚ä¿®æ”¹æ ·å¼ã€è·å–å±æ€§ç­‰
        //     if (clickedElement) {
        //         // ä¾‹å¦‚ï¼šé«˜äº®æ˜¾ç¤ºç‚¹å‡»çš„å…ƒç´ 
        //         const originalStyle = clickedElement.style.backgroundColor;
        //         clickedElement.style.backgroundColor = '#ffcc00';

        //         // 3ç§’åæ¢å¤æ ·å¼
        //         setTimeout(() => {
        //             clickedElement.style.backgroundColor = originalStyle;
        //         }, 3000);
        //     }
        // });

        function startIntro(beautyIntro) {
            try {
                beautyIntro.start();
                // playVideo()
                // document.addEventListener('click', function () {
                //     beautyIntro.exit(); // ç›´æ¥è°ƒç”¨exitæ–¹æ³•å…³é—­å¼•å¯¼
                // });
            } catch (error) {
                console.log(error);
            }
        }
        function startIntroComplete(beautyIntro) {
            try {
                beautyIntro.oncomplete(
                    function () {
                        // æ·»åŠ ä¸€ä¸ªCookieï¼Œè¡¨ç¤ºç”¨æˆ·å·²ç»å®Œæˆå¼•å¯¼
                        localStorage.setItem('introjs-dontShowAgain', 1);
                    }
                ).start();
            } catch (error) {
                console.log(error);
            }
        }
        function playVideo() {
            var video = document.querySelector('video');
            if (video.paused) {
                video.play();
            } else {
                video.pause();
            }
        }
        function guaidance1() {
            setTimeout(() => {
                const beautyIntro = MultiIntro([{
                    element: '#node-0', intro: `\
                        <center>
                        <div>åŒå‡»èŠ‚ç‚¹ï¼Œä¿®æ”¹å†…å®¹ä¸ºä½ æƒ³è¦çš„è°ƒç ”çš„å“ç±»</div>
                        <div style='color:#888'>ï¼ˆæ‰€æœ‰èŠ‚ç‚¹éƒ½å¯ä»¥ç›¸äº’ååº”ï¼Œ<strong>é”å®šèŠ‚ç‚¹ç”Ÿæˆçš„è¡¨æ ¼èŠ‚ç‚¹é™¤å¤–</strong>ï¼‰</div>
                        <video muted autoplay loop>
                            <source src="xsjc1.min.mp4" type="video/mp4">
                        </video>
                        </center>
                        `, position: 'bottom'
                }, {
                    element: '#node-2', intro: `\
                        <center>
                        <div>å°†åˆšæ‰ä¿®æ”¹åçš„èŠ‚ç‚¹æ‹–åŠ¨åˆ°ç°åœ¨çš„ã€é”å®šèŠ‚ç‚¹ã€‘ä¸Šï¼Œé”å®šèŠ‚ç‚¹ä¸å¯è¢«åˆ é™¤</div>
                        <video muted autoplay loop>
                            <source src="xsjc2.min.mp4" type="video/mp4">
                        </video>
                        </center>
                        `, position: 'bottom'
                }]);
                startIntro(beautyIntro)
            }, 100);
        }
        // <div style='color:#888'>(å•å‡»ã€ç©ºç™½å¤„ã€‘ç»§ç»­æ“ä½œ)</div>
        // function guaidance2() {
        //     setTimeout(() => {
        //         const beautyIntro = OnceIntro('#node-2', `\
        //                 <center>
        //                 <div>å°†åˆšæ‰ä¿®æ”¹åçš„èŠ‚ç‚¹æ‹–åŠ¨åˆ°ç°åœ¨çš„ã€é”å®šèŠ‚ç‚¹ã€‘ä¸Šï¼Œé”å®šèŠ‚ç‚¹ä¸å¯è¢«åˆ é™¤</div>
        //                 <video muted autoplay loop>
        //                     <source src="xsjc2.min.mp4" type="video/mp4">
        //                 </video>
        //                 </center>
        //                 `, 'bottom')
        //         startIntro(beautyIntro)
        //     }, 100);
        // }
        function guaidance3() {
            setTimeout(() => {
                const beautyIntro = MultiIntro([{
                    element: '#api-call-indicator',
                    intro: `\
                        <center>
                        <div>ç­‰å¾…å—ç¥æ€è€ƒå®Œæ¯•</div>
                        </center>
                        `,
                    position: 'bottom'
                }, {
                    element: '#node-3',
                    intro: `\
                        <center>
                        <div>ä¸é”å®šèŠ‚ç‚¹ååº”æ—¶ï¼Œå¯ä»¥è§£é”éƒ¨åˆ†æ–°é”å®šèŠ‚ç‚¹,æ–°é”å®šèŠ‚ç‚¹ä¼šéšæœºåˆ·æ–°åœ¨é™„è¿‘çš„ç©ºç™½å¤„</div>
                        <div>ï¼ˆé”å®šèŠ‚ç‚¹éAIç”Ÿæˆï¼Œä»…æä¾›æ€ç»´æ¨¡å¼ï¼‰</div>
                        <div></div>
                        <div style='color:#888'>ä½¿ç”¨æ—¶å»ºè®®å°†èŠ‚ç‚¹æ‹–æ‹½å‡ºç©ºæ—·å¤„ååº”ï¼Œä»¥å…ä¹±æˆä¸€å›¢</div>
                        <video muted autoplay loop>
                            <source src="SuggestDragging2Blank.min.mp4" type="video/mp4">
                        </video>
                        </center>
                        `,
                    position: 'left'
                }, {
                    element: '#node-0',
                    intro: `\
                        <center>
                        <div>å‚è€ƒæ–°ç”Ÿæˆçš„å…³é”®è¯ï¼Œå¯ä»¥å¯¹åˆå§‹å…³é”®è¯è¿›è¡Œä¿®æ”¹å®Œå–„</div>
                        <div>ï¼ˆå…¶ä½™å…³é”®è¯èŠ‚ç‚¹äº¦å¯ï¼‰</div>
                        <video muted autoplay loop>
                            <source src="Improvekeywords.min.mp4" type="video/mp4">
                        </video>
                        </center>
                        `,
                    position: 'bottom'
                }, {
                    element: '#node-2',
                    intro: `\
                        <center>
                            <div>ä¿®æ”¹å®Œå…³é”®è¯èŠ‚ç‚¹åï¼Œå¯ä»¥é‡æ–°æ‹–æ‹½è‡³è¯¥èŠ‚ç‚¹ç”Ÿæˆæ–°å…³é”®è¯</div>
                            <video muted autoplay loop>
                                <source src="CanRepeat.min.mp4" type="video/mp4">
                            </video>
                        </center>
                            `,
                    position: 'bottom'
                }, {
                    element: '#trash-can-btn',
                    intro: `\
                        <center>
                            <div>ä¸è¦çš„å…³é”®è¯èŠ‚ç‚¹å¯ä»¥æ‹–æ‹½è‡³å›æ”¶ç«™</div>
                            <video muted autoplay loop>
                                <source src="Move2Crash.min.mp4" type="video/mp4">
                            </video>
                        </center>
                            `,
                    position: 'bottom'
                }, {
                    element: '#reset-view-btn',
                    intro: `\
                        <center>
                            <div>å½“æ‹–æ‹½ç”»å¸ƒè¿‡è¿œåï¼Œæ— æ³•å°†ç”»å¸ƒæ‹–å›å±å¹•ï¼Œå¯ä»¥å•å‡»æ­¤æŒ‰é’®å°†ç”»å¸ƒå¤ä½äºå±å¹•ä¸­å¿ƒ</div>
                            <video muted autoplay loop>
                                <source src="Turn2Center.min.mp4" type="video/mp4">
                            </video>
                        </center>
                            `,
                    position: 'bottom'
                }, {
                    element: '#add-node-btn',
                    intro: `\
                        <center>
                            <div>å½“ä¸å°å¿ƒå°†æ‰€æœ‰å¯ç¼–è¾‘èŠ‚ç‚¹å…¨éƒ¨åˆ é™¤æˆ–æ˜¯éœ€è¦ä¸€ä¸ªæ–°çš„å¯ç¼–è¾‘èŠ‚ç‚¹æ—¶ï¼Œå•å‡»æ­¤æŒ‰é’®å¯ä»¥åœ¨ç©ºç™½å¤„æ–°å»ºä¸€ä¸ªå¯ç¼–è¾‘èŠ‚ç‚¹</div>
                            <video muted autoplay loop>
                                <source src="AddNewNode.min.mp4" type="video/mp4">
                            </video>
                        </center>
                        `,
                    position: 'bottom'
                }, {
                    element: 'body',
                    intro: `\
                        <center>
                        <div>æ–°æ‰‹æ•™ç¨‹å·²ç»“æŸï¼Œæ„Ÿè°¢æ‚¨çš„ä½¿ç”¨</div>
                        </center>
                        `,
                    position: 'bottom'
                },
                ])
                startIntroComplete(beautyIntro)
            }, 100);
        }
        function guaidance4(nodeId) {
            setTimeout(() => {
                const beautyIntro = OnceIntro(nodeId, `\
                        <center>
                        <div>è¡¨æ ¼èŠ‚ç‚¹çš†ä¸å¯ä¸å…¶ä»–èŠ‚ç‚¹ååº”</div>
                        </center>
                        `, 'bottom')
                startIntro(beautyIntro)
            }, 1000);
        }
        guaidance1()
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const html = document.body.parentNode;
            const body = document.body;
            const canvasContainer = document.getElementById('canvas-container');
            const addNodeButton = document.getElementById('add-node-btn');
            const resetViewButton = document.getElementById('reset-view-btn');
            const addLockedNodeButton = document.getElementById('add-locked-node-btn');
            // const trashCan = document.getElementById('trash-can');
            const trashCan = document.getElementById('trash-can-btn');
            const apiIndicator = document.getElementById('api-call-indicator');
            const apiIndicatorFailed = document.getElementById('api-call-indicator-Failed');

            let isDraggingCanvas = false;
            let startX, startY;
            let nodeIdCounter = 0;
            const nodes = new Map();
            let activeDragNode = null;
            let dragStartX, dragStartY;

            // --- Zoom and Pan Variables ---
            let scale = 1;
            let isPinching = false;
            let initialPinchDistance = 0;
            let lastTouchCenterX = 0;
            let lastTouchCenterY = 0;
            let initialScale = 1;
            // --- Overlap Logic Variables ---
            let pendingApiCall = null; // ç”¨äºå­˜å‚¨å¾…è§¦å‘çš„APIè°ƒç”¨ä¿¡æ¯
            // æ–°å¢ï¼šç”¨äºè·Ÿè¸ªèŠ‚ç‚¹ååº”å†å²
            const nodeReactionHistory = new Set(); // å­˜å‚¨å·²ååº”çš„èŠ‚ç‚¹ID

            // --- Trash Can Logic Variables ---
            let isDraggingToTrash = false;

            // --- Z-index Management ---
            let maxZIndex = 10; // åˆå§‹æœ€å¤§z-index

            // ä¾§è¾¹æ 
            const sidebarItems = document.querySelectorAll('.sidebar-item');

            sidebarItems.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    item.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', item.dataset.content);
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                });
            });

            canvasContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            canvasContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                const content = e.dataTransfer.getData('text/plain');
                if (content) {
                    // è·å–ç”»å¸ƒå®¹å™¨ç›¸å¯¹äºè§†å£çš„ä½ç½®
                    const rect = canvasContainer.getBoundingClientRect();
                    // è®¡ç®—èŠ‚ç‚¹åœ¨ç”»å¸ƒä¸Šçš„ä½ç½®ï¼ˆè€ƒè™‘ç¼©æ”¾ï¼‰
                    const x = (e.clientX - rect.left);
                    const y = (e.clientY - rect.top);
                    createNode(x, y, content, 1);
                }
            });

            // --- Utility Functions ---
            function getOverlapArea(nodeA, nodeB) {
                const left = Math.max(nodeA.x, nodeB.x);
                const right = Math.min(nodeA.x + nodeA.width, nodeB.x + nodeB.width);
                const top = Math.max(nodeA.y, nodeB.y);
                const bottom = Math.min(nodeA.y + nodeA.height, nodeB.y + nodeB.height);

                if (left < right && top < bottom) {
                    return (right - left) * (bottom - top);
                }
                return 0;
            }

            function getArea(node) {
                return node.width * node.height;
            }

            // è®¡ç®—ä¸€ç»„èŠ‚ç‚¹çš„è¾¹ç•Œæ¡†ä¸­å¿ƒï¼Œå¹¶ç§»åŠ¨ç”»å¸ƒä½¿å…¶å±…ä¸­
            function centerViewOnNodes(nodeList) {
                if (nodeList.length === 0) return;

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

                nodeList.forEach(node => {
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x + node.width);
                    maxY = Math.max(maxY, node.y + node.height);
                });

                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                const viewportWidth = canvasContainer.clientWidth;
                const viewportHeight = canvasContainer.clientHeight;

                // ä¿®å¤ï¼šæ­£ç¡®è®¡ç®—è€ƒè™‘ç¼©æ”¾å’Œç”»å¸ƒåç§»çš„æ»šåŠ¨ä½ç½®
                const containerRect = canvasContainer.getBoundingClientRect();
                canvasContainer.scrollTo({
                    left: centerX * scale - viewportWidth / 2 - containerRect.left,
                    top: centerY * scale - viewportHeight / 2 - containerRect.top,
                    behavior: 'smooth'
                });
            }

            // æ–°å¢ï¼šé‡ç½®è§†å›¾åˆ°ä¸­å¿ƒç‚¹åŠŸèƒ½
            function resetViewToCenter() {
                // é‡ç½®bodyå’Œhtmlçš„left/topä¸º0
                body.style.marginLeft = '0px';
                body.style.marginTop = '0px';
                html.style.marginLeft = '0px';
                html.style.marginTop = '0px';
                canvasContainer.style.left = '0px';
                canvasContainer.style.top = '0px';

                // è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹çš„ä¸­å¿ƒä½ç½®å¹¶å±…ä¸­æ˜¾ç¤º
                if (nodes.size > 0) {
                    const allNodes = Array.from(nodes.values());
                    centerViewOnNodes(allNodes);
                }
            }

            // --- Zoom Functions ---
            function setScale(newScale, mouseX, mouseY) {
                const oldScale = scale;
                // é™åˆ¶ç¼©æ”¾èŒƒå›´
                scale = Math.min(Math.max(0.1, newScale), 5);

                // å¦‚æœæä¾›äº†é¼ æ ‡åæ ‡ï¼Œåˆ™ä»¥è¯¥ç‚¹ä¸ºä¸­å¿ƒè¿›è¡Œç¼©æ”¾
                if (mouseX !== undefined && mouseY !== undefined) {
                    // è®¡ç®—ä¸–ç•Œåæ ‡ (ç¼©æ”¾å‰)
                    const worldX = (mouseX + canvasContainer.scrollLeft) / oldScale;
                    const worldY = (mouseY + canvasContainer.scrollTop) / oldScale;

                    canvasContainer.style.transform = `scale(${scale})`;

                    // è°ƒæ•´ scrollLeft å’Œ scrollTop ä»¥ä½¿ç¼©æ”¾ä¸­å¿ƒä¿æŒåœ¨é¼ æ ‡ä½ç½®
                    canvasContainer.scrollLeft = worldX * scale - mouseX;
                    canvasContainer.scrollTop = worldY * scale - mouseY;
                } else {
                    // å¦‚æœæ²¡æœ‰æä¾›é¼ æ ‡åæ ‡ï¼Œåˆ™åœ¨å½“å‰è§†å›¾ä¸­å¿ƒç¼©æ”¾
                    const rect = canvasContainer.getBoundingClientRect();
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    const worldX = (centerX + canvasContainer.scrollLeft) / oldScale;
                    const worldY = (centerY + canvasContainer.scrollTop) / oldScale;

                    canvasContainer.style.transform = `scale(${scale})`;

                    canvasContainer.scrollLeft = worldX * scale - centerX;
                    canvasContainer.scrollTop = worldY * scale - centerY;
                }
                // è°ƒæ•´èƒŒæ™¯ç½‘æ ¼å¤§å°ä»¥é€‚åº”ç¼©æ”¾
                const gridSize = 30 * scale;
                canvasContainer.style.backgroundSize = `${gridSize}px ${gridSize}px`;
            }

            function handleWheel(e) {
                e.preventDefault();
                const rect = canvasContainer.getBoundingClientRect();
                // è·å–é¼ æ ‡ç›¸å¯¹äºç”»å¸ƒå®¹å™¨å·¦ä¸Šè§’çš„ä½ç½®
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // æ ¹æ®æ»šåŠ¨æ–¹å‘è°ƒæ•´ç¼©æ”¾æ¯”ä¾‹
                const zoomIntensity = 0.1;
                const wheel = e.deltaY < 0 ? 1 : -1;
                console.log('wheel', e.deltaY);
                const zoom = Math.exp(wheel * zoomIntensity);
                setScale(scale * zoom, mouseX, mouseY);
            }

            // --- Touch Event Handlers for Pinch Zoom ---
            function getDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function getMidpoint(touch1, touch2) {
                return {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
            }
            function EndEditing() {
                nodes.forEach(node => {
                    if (node.isEditing) {
                        // æ‰¾åˆ°æ­£åœ¨ç¼–è¾‘çš„èŠ‚ç‚¹å¹¶ä¿å­˜
                        const textarea = node.element.querySelector('textarea');
                        if (textarea) {
                            const newText = textarea.value.trim() || 'ç¼–è¾‘æˆ‘...';
                            node.element.classList.remove('editing');
                            node.element.textContent = newText;
                            node.isEditing = false;
                            requestAnimationFrame(() => {
                                node.width = node.element.offsetWidth;
                                node.height = node.element.offsetHeight;
                            });
                        }
                    }
                });
            }

            canvasContainer.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    isPinching = true;
                    initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
                    const midpoint = getMidpoint(e.touches[0], e.touches[1]);
                    const rect = canvasContainer.getBoundingClientRect();
                    lastTouchCenterX = midpoint.x - rect.left;
                    lastTouchCenterY = midpoint.y - rect.top;
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„åŒæŒ‡è¡Œä¸ºï¼ˆå¦‚ç¼©æ”¾é¡µé¢ï¼‰
                } else if (e.touches.length === 1 && !isPinching) {
                    // å•æŒ‡è§¦æ‘¸å¼€å§‹ï¼Œç”¨äºæ‹–ç”»ç”»å¸ƒ
                    isDraggingCanvas = true;
                    canvasContainer.classList.add('dragging');
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    const computedStyle = window.getComputedStyle(canvasContainer);
                    startLeft = parseFloat(computedStyle.left) || 0;
                    startTop = parseFloat(computedStyle.top) || 0;
                    // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé˜²æ­¢æ„å¤–é€‰ä¸­å…ƒç´ 
                    e.preventDefault();
                }
                EndEditing()
            });

            canvasContainer.addEventListener('touchmove', (e) => {
                if (isPinching && e.touches.length === 2) {
                    // åŒæŒ‡ç¼©æ”¾
                    const currentPinchDistance = getDistance(e.touches[0], e.touches[1]);
                    const scaleChange = currentPinchDistance / initialPinchDistance;
                    const newScale = initialScale * scaleChange;


                    // é™åˆ¶ç¼©æ”¾èŒƒå›´
                    if (newScale > 0.1 && newScale < 5) {
                        scale = newScale;
                        canvasContainer.style.transform = `scale(${scale})`;

                        // è°ƒæ•´èƒŒæ™¯ç½‘æ ¼å¤§å°ä»¥é€‚åº”ç¼©æ”¾
                        const gridSize = 30 * scale;
                        canvasContainer.style.backgroundSize = `${gridSize}px ${gridSize}px`;
                    }

                    // åŒæŒ‡ä¸­å¿ƒç‚¹ä¸–ç•Œåæ ‡ä¿æŒä¸å˜
                    const midpoint = getMidpoint(e.touches[0], e.touches[1]);
                    const rect = canvasContainer.getBoundingClientRect();
                    const currentTouchCenterX = midpoint.x - rect.left;
                    const currentTouchCenterY = midpoint.y - rect.top;

                    lastTouchCenterX = currentTouchCenterX;
                    lastTouchCenterY = currentTouchCenterY;
                    e.preventDefault();
                }
                if (isDraggingCanvas && e.touches.length === 1) {
                    // å•æŒ‡æ‹–ç”»ç”»å¸ƒ
                    const dx = e.touches[0].clientX - startX;
                    const dy = e.touches[0].clientY - startY;
                    canvasContainer.style.left = (startLeft + dx) + 'px';
                    canvasContainer.style.top = (startTop + dy) + 'px';
                    e.preventDefault();
                } else if (activeDragNode) {
                    // æ‹–åŠ¨èŠ‚ç‚¹ (ç§»åŠ¨ç«¯)
                    const dx = e.touches[0].clientX - dragStartX;
                    const dy = e.touches[0].clientY - dragStartY;
                    // ç”±äºèŠ‚ç‚¹æ˜¯ç»å¯¹å®šä½çš„ï¼Œæ‹–åŠ¨è·ç¦»ä¸åº”å—ç¼©æ”¾å½±å“
                    activeDragNode.x += dx / scale;
                    activeDragNode.y += dy / scale;
                    activeDragNode.element.style.left = `${activeDragNode.x}px`;
                    activeDragNode.element.style.top = `${activeDragNode.y}px`;
                    dragStartX = e.touches[0].clientX;
                    dragStartY = e.touches[0].clientY;

                    activeDragNode.width = activeDragNode.element.offsetWidth;
                    activeDragNode.height = activeDragNode.element.offsetHeight;

                    // åœ¨æ‹–åŠ¨è¿‡ç¨‹ä¸­æ£€æŸ¥é‡å ï¼Œä½†ä¸ç«‹å³è§¦å‘API
                    checkOverlapDuringDrag(activeDragNode);

                    // æ£€æŸ¥æ˜¯å¦æ‹–åˆ°åƒåœ¾æ¡¶
                    checkTrashCanHover(e.touches[0].clientX, e.touches[0].clientY);
                    e.preventDefault();
                }
            });

            body.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    isPinching = true;
                    initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
                    const midpoint = getMidpoint(e.touches[0], e.touches[1]);
                    const rect = canvasContainer.getBoundingClientRect();
                    lastTouchCenterX = midpoint.x - rect.left;
                    lastTouchCenterY = midpoint.y - rect.top;
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„åŒæŒ‡è¡Œä¸ºï¼ˆå¦‚ç¼©æ”¾é¡µé¢ï¼‰
                } else if (e.touches.length === 1 && !isPinching) {
                    // å•æŒ‡è§¦æ‘¸å¼€å§‹ï¼Œç”¨äºæ‹–ç”»ç”»å¸ƒ
                    isDraggingCanvas = true;
                    canvasContainer.classList.add('dragging');
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    const computedStyle = window.getComputedStyle(canvasContainer);
                    startLeft = parseFloat(computedStyle.left) || 0;
                    startTop = parseFloat(computedStyle.top) || 0;
                    // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé˜²æ­¢æ„å¤–é€‰ä¸­å…ƒç´ 
                    e.preventDefault();
                }
                EndEditing()
            });

            body.addEventListener('touchmove', (e) => {
                if (isPinching && e.touches.length === 2) {
                    // åŒæŒ‡ç¼©æ”¾
                    const currentPinchDistance = getDistance(e.touches[0], e.touches[1]);
                    const scaleChange = currentPinchDistance / initialPinchDistance;
                    const newScale = initialScale * scaleChange;


                    // é™åˆ¶ç¼©æ”¾èŒƒå›´
                    if (newScale > 0.1 && newScale < 5) {
                        scale = newScale;
                        canvasContainer.style.transform = `scale(${scale})`;

                        // è°ƒæ•´èƒŒæ™¯ç½‘æ ¼å¤§å°ä»¥é€‚åº”ç¼©æ”¾
                        const gridSize = 30 * scale;
                        canvasContainer.style.backgroundSize = `${gridSize}px ${gridSize}px`;
                    }

                    // åŒæŒ‡ä¸­å¿ƒç‚¹ä¸–ç•Œåæ ‡ä¿æŒä¸å˜
                    const midpoint = getMidpoint(e.touches[0], e.touches[1]);
                    const rect = canvasContainer.getBoundingClientRect();
                    const currentTouchCenterX = midpoint.x - rect.left;
                    const currentTouchCenterY = midpoint.y - rect.top;

                    lastTouchCenterX = currentTouchCenterX;
                    lastTouchCenterY = currentTouchCenterY;
                    e.preventDefault();
                }
                if (isDraggingCanvas && e.touches.length === 1) {
                    // å•æŒ‡æ‹–ç”»ç”»å¸ƒ
                    const dx = e.touches[0].clientX - startX;
                    const dy = e.touches[0].clientY - startY;
                    canvasContainer.style.left = (startLeft + dx) + 'px';
                    canvasContainer.style.top = (startTop + dy) + 'px';
                    e.preventDefault();
                } else if (activeDragNode) {
                    // æ‹–åŠ¨èŠ‚ç‚¹ (ç§»åŠ¨ç«¯)
                    const dx = e.touches[0].clientX - dragStartX;
                    const dy = e.touches[0].clientY - dragStartY;
                    // ç”±äºèŠ‚ç‚¹æ˜¯ç»å¯¹å®šä½çš„ï¼Œæ‹–åŠ¨è·ç¦»ä¸åº”å—ç¼©æ”¾å½±å“
                    activeDragNode.x += dx / scale;
                    activeDragNode.y += dy / scale;
                    activeDragNode.element.style.left = `${activeDragNode.x}px`;
                    activeDragNode.element.style.top = `${activeDragNode.y}px`;
                    dragStartX = e.touches[0].clientX;
                    dragStartY = e.touches[0].clientY;

                    activeDragNode.width = activeDragNode.element.offsetWidth;
                    activeDragNode.height = activeDragNode.element.offsetHeight;

                    // åœ¨æ‹–åŠ¨è¿‡ç¨‹ä¸­æ£€æŸ¥é‡å ï¼Œä½†ä¸ç«‹å³è§¦å‘API
                    checkOverlapDuringDrag(activeDragNode);

                    // æ£€æŸ¥æ˜¯å¦æ‹–åˆ°åƒåœ¾æ¡¶
                    checkTrashCanHover(e.touches[0].clientX, e.touches[0].clientY);
                    e.preventDefault();
                }
            });

            html.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    isPinching = true;
                    initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
                    const midpoint = getMidpoint(e.touches[0], e.touches[1]);
                    const rect = canvasContainer.getBoundingClientRect();
                    lastTouchCenterX = midpoint.x - rect.left;
                    lastTouchCenterY = midpoint.y - rect.top;
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„åŒæŒ‡è¡Œä¸ºï¼ˆå¦‚ç¼©æ”¾é¡µé¢ï¼‰
                } else if (e.touches.length === 1 && !isPinching) {
                    // å•æŒ‡è§¦æ‘¸å¼€å§‹ï¼Œç”¨äºæ‹–ç”»ç”»å¸ƒ
                    isDraggingCanvas = true;
                    canvasContainer.classList.add('dragging');
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    const computedStyle = window.getComputedStyle(canvasContainer);
                    startLeft = parseFloat(computedStyle.left) || 0;
                    startTop = parseFloat(computedStyle.top) || 0;
                    // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé˜²æ­¢æ„å¤–é€‰ä¸­å…ƒç´ 
                    e.preventDefault();
                }
                EndEditing()
            });

            html.addEventListener('touchmove', (e) => {
                if (isPinching && e.touches.length === 2) {
                    // åŒæŒ‡ç¼©æ”¾
                    const currentPinchDistance = getDistance(e.touches[0], e.touches[1]);
                    const scaleChange = currentPinchDistance / initialPinchDistance;
                    const newScale = initialScale * scaleChange;


                    // é™åˆ¶ç¼©æ”¾èŒƒå›´
                    if (newScale > 0.1 && newScale < 5) {
                        scale = newScale;
                        canvasContainer.style.transform = `scale(${scale})`;

                        // è°ƒæ•´èƒŒæ™¯ç½‘æ ¼å¤§å°ä»¥é€‚åº”ç¼©æ”¾
                        const gridSize = 30 * scale;
                        canvasContainer.style.backgroundSize = `${gridSize}px ${gridSize}px`;
                    }

                    // åŒæŒ‡ä¸­å¿ƒç‚¹ä¸–ç•Œåæ ‡ä¿æŒä¸å˜
                    const midpoint = getMidpoint(e.touches[0], e.touches[1]);
                    const rect = canvasContainer.getBoundingClientRect();
                    const currentTouchCenterX = midpoint.x - rect.left;
                    const currentTouchCenterY = midpoint.y - rect.top;

                    lastTouchCenterX = currentTouchCenterX;
                    lastTouchCenterY = currentTouchCenterY;
                    e.preventDefault();
                }
                if (isDraggingCanvas && e.touches.length === 1) {
                    // å•æŒ‡æ‹–ç”»ç”»å¸ƒ
                    const dx = e.touches[0].clientX - startX;
                    const dy = e.touches[0].clientY - startY;
                    canvasContainer.style.left = (startLeft + dx) + 'px';
                    canvasContainer.style.top = (startTop + dy) + 'px';
                    e.preventDefault();
                } else if (activeDragNode) {
                    // æ‹–åŠ¨èŠ‚ç‚¹ (ç§»åŠ¨ç«¯)
                    const dx = e.touches[0].clientX - dragStartX;
                    const dy = e.touches[0].clientY - dragStartY;
                    // ç”±äºèŠ‚ç‚¹æ˜¯ç»å¯¹å®šä½çš„ï¼Œæ‹–åŠ¨è·ç¦»ä¸åº”å—ç¼©æ”¾å½±å“
                    activeDragNode.x += dx / scale;
                    activeDragNode.y += dy / scale;
                    activeDragNode.element.style.left = `${activeDragNode.x}px`;
                    activeDragNode.element.style.top = `${activeDragNode.y}px`;
                    dragStartX = e.touches[0].clientX;
                    dragStartY = e.touches[0].clientY;

                    activeDragNode.width = activeDragNode.element.offsetWidth;
                    activeDragNode.height = activeDragNode.element.offsetHeight;

                    // åœ¨æ‹–åŠ¨è¿‡ç¨‹ä¸­æ£€æŸ¥é‡å ï¼Œä½†ä¸ç«‹å³è§¦å‘API
                    checkOverlapDuringDrag(activeDragNode);

                    // æ£€æŸ¥æ˜¯å¦æ‹–åˆ°åƒåœ¾æ¡¶
                    checkTrashCanHover(e.touches[0].clientX, e.touches[0].clientY);
                    e.preventDefault();
                }
            });

            document.addEventListener('touchend', (e) => {
                if (isPinching) {
                    if (e.touches.length === 1) {
                        initialPinchDistance = 0;
                        isPinching = false;
                    } else if (e.touches.length === 0) {
                        isPinching = false;
                        initialPinchDistance = 0;
                    }
                }
                if (isDraggingCanvas) {
                    isDraggingCanvas = false;
                    canvasContainer.classList.remove('dragging');
                }
                // æ·»åŠ : åœ¨ç§»åŠ¨ç«¯è§¦æ‘¸ç»“æŸæ—¶æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†ç©ºç™½å¤„
                if (activeDragNode) {
                    // --- ä¿®æ”¹ï¼šåœ¨ç§»åŠ¨ç«¯è§¦æ‘¸ç»“æŸæ—¶ä¹Ÿæ£€æŸ¥åƒåœ¾æ¡¶çŠ¶æ€ ---
                    if (isDraggingToTrash) {
                        // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å¯åˆ é™¤
                        if (activeDragNode.locked) {
                            console.log(`èŠ‚ç‚¹ ${activeDragNode.id} æ˜¯é”å®šçš„ï¼Œæ— æ³•åˆ é™¤ã€‚`);
                            activeDragNode.element.style.animation = 'shake 0.5s';
                            setTimeout(() => {
                                activeDragNode.element.style.animation = '';
                            }, 500);
                        } else {
                            deleteNode(activeDragNode.id);
                        }
                        isDraggingToTrash = false;
                        trashCan.classList.remove('active');
                    }
                    endDrag(activeDragNode);
                }
            });


            // --- Core Interaction Logic ---

            // Canvas Panning (é¼ æ ‡)
            canvasContainer.addEventListener('mousedown', (e) => {
                // å¦‚æœç‚¹å‡»çš„æ˜¯ç”»å¸ƒï¼Œç»“æŸæ‰€æœ‰èŠ‚ç‚¹çš„ç¼–è¾‘çŠ¶æ€
                if (e.target === canvasContainer) {
                    EndEditing()
                }

                if (e.target === canvasContainer) {
                    isDraggingCanvas = true;
                    canvasContainer.classList.add('dragging');
                    startX = e.clientX;
                    startY = e.clientY;
                    // ä¿å­˜å½“å‰çš„leftå’Œtopå€¼
                    const computedStyle = window.getComputedStyle(canvasContainer);
                    startLeft = parseFloat(computedStyle.left) || 0;
                    startTop = parseFloat(computedStyle.top) || 0;
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isDraggingCanvas) {
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    // ä¿®æ”¹ä¸ºç›´æ¥ä¿®æ”¹leftå’Œtopæ ·å¼å±æ€§
                    canvasContainer.style.left = (startLeft + dx) + 'px';
                    canvasContainer.style.top = (startTop + dy) + 'px';
                } else if (activeDragNode) {
                    const dx = e.clientX - dragStartX;
                    const dy = e.clientY - dragStartY;
                    // ç”±äºèŠ‚ç‚¹æ˜¯ç»å¯¹å®šä½çš„ï¼Œæ‹–åŠ¨è·ç¦»ä¸åº”å—ç¼©æ”¾å½±å“
                    activeDragNode.x += dx / scale;
                    activeDragNode.y += dy / scale;
                    activeDragNode.element.style.left = `${activeDragNode.x}px`;
                    activeDragNode.element.style.top = `${activeDragNode.y}px`;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;

                    activeDragNode.width = activeDragNode.element.offsetWidth;
                    activeDragNode.height = activeDragNode.element.offsetHeight;

                    // åœ¨æ‹–åŠ¨è¿‡ç¨‹ä¸­æ£€æŸ¥é‡å ï¼Œä½†ä¸ç«‹å³è§¦å‘API
                    checkOverlapDuringDrag(activeDragNode);

                    // æ£€æŸ¥æ˜¯å¦æ‹–åˆ°åƒåœ¾æ¡¶
                    checkTrashCanHover(e.clientX, e.clientY);
                }
            });

            document.addEventListener('mouseup', () => {
                isDraggingCanvas = false;
                canvasContainer.classList.remove('dragging');

                if (activeDragNode) {
                    endDrag(activeDragNode);
                }
            });

            // bodyéƒ¨åˆ†
            body.addEventListener('mousedown', (e) => {
                // å¦‚æœç‚¹å‡»çš„æ˜¯ç”»å¸ƒï¼Œç»“æŸæ‰€æœ‰èŠ‚ç‚¹çš„ç¼–è¾‘çŠ¶æ€
                if (e.target === body) {
                    EndEditing()
                }

                if (e.target === body) {
                    isDraggingCanvas = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    // ä¿å­˜å½“å‰çš„leftå’Œtopå€¼
                    const computedStyle = window.getComputedStyle(canvasContainer);
                    startLeft = parseFloat(computedStyle.left) || 0;
                    startTop = parseFloat(computedStyle.top) || 0;
                    e.preventDefault();
                }
            });

            // htmléƒ¨åˆ†
            html.addEventListener('mousedown', (e) => {
                // å¦‚æœç‚¹å‡»çš„æ˜¯ç”»å¸ƒï¼Œç»“æŸæ‰€æœ‰èŠ‚ç‚¹çš„ç¼–è¾‘çŠ¶æ€
                if (e.target === html) {
                    EndEditing()
                }

                if (e.target === html) {
                    isDraggingCanvas = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    // ä¿å­˜å½“å‰çš„leftå’Œtopå€¼
                    const computedStyle = window.getComputedStyle(canvasContainer);
                    startLeft = parseFloat(computedStyle.left) || 0;
                    startTop = parseFloat(computedStyle.top) || 0;
                    e.preventDefault();
                }
            });


            function endDrag(draggedNode) {
                draggedNode.element.classList.remove('dragging');
                nodes.forEach(node => {
                    node.element.classList.remove('overlapping');
                });

                // --- ä¿®æ”¹ï¼šåœ¨æ‹–æ‹½ç»“æŸæ—¶ä¹Ÿå¤„ç†åƒåœ¾æ¡¶é€»è¾‘ ---
                if (isDraggingToTrash) {
                    // --- ä¿®æ”¹ï¼šæ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å¯åˆ é™¤ ---
                    if (draggedNode.locked) {
                        console.log(`èŠ‚ç‚¹ ${draggedNode.id} æ˜¯é”å®šçš„ï¼Œæ— æ³•åˆ é™¤ã€‚`);
                        // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ è§†è§‰åé¦ˆï¼Œæ¯”å¦‚é—ªçƒæˆ–æç¤º
                        draggedNode.element.style.animation = 'shake 0.5s';
                        setTimeout(() => {
                            draggedNode.element.style.animation = '';
                        }, 500);
                    } else {
                        deleteNode(draggedNode.id);
                    }
                    isDraggingToTrash = false;
                    trashCan.classList.remove('active');
                } else {
                    // --- å…³é”®ä¿®æ”¹ï¼šåœ¨æ¾å¼€é¼ æ ‡æ—¶æ£€æŸ¥å¹¶è§¦å‘API ---
                    if (pendingApiCall) {
                        callApiAndCreateNodes(pendingApiCall.nodeA, pendingApiCall.nodeB);
                        pendingApiCall = null; // é‡ç½®
                    }
                }

                activeDragNode = null;
            }

            // åˆ é™¤èŠ‚ç‚¹å‡½æ•°
            function deleteNode(nodeId) {
                const node = nodes.get(nodeId);
                if (node) {
                    node.element.remove();
                    nodes.delete(nodeId);
                }
            }

            // æ·»åŠ åƒåœ¾æ¡¶æ‚¬åœæ£€æŸ¥
            function checkTrashCanHover(clientX, clientY) {
                const trashRect = trashCan.getBoundingClientRect();
                const isOverTrash = (
                    clientX >= trashRect.left &&
                    clientX <= trashRect.right &&
                    clientY >= trashRect.top &&
                    clientY <= trashRect.bottom
                );

                if (isOverTrash) {
                    trashCan.classList.add('active');
                    isDraggingToTrash = true;
                } else {
                    trashCan.classList.remove('active');
                    isDraggingToTrash = false;
                }
            }

            // Add Node Button
            addNodeButton.addEventListener('click', (e) => {
                // åœ¨è§†å£ä¸­å¿ƒåˆ›å»ºèŠ‚ç‚¹ï¼Œéœ€è¦è€ƒè™‘ç¼©æ”¾å’Œæ»šåŠ¨
                const x = (canvasContainer.scrollLeft + canvasContainer.clientWidth / 2) / scale - 65;
                const y = (canvasContainer.scrollTop + canvasContainer.clientHeight / 2) / scale - 35;
                createNode(x, y);
            });

            // æ–°å¢ï¼šç»‘å®šé‡ç½®è§†å›¾æŒ‰é’®äº‹ä»¶
            resetViewButton.addEventListener('click', resetViewToCenter);

            function unlockNode(NodeName = '') {
                // console.log(NodeName);
                for (const [id, node] of nodes) {
                    if (node.locked && NodeName.includes(node.element.textContent)) {
                        console.log(`é”å®šèŠ‚ç‚¹ "${NodeName}" å·²å­˜åœ¨ï¼Œæ— éœ€é‡å¤åˆ›å»º`);
                        return; // å¦‚æœå·²å­˜åœ¨ï¼Œç›´æ¥è¿”å›ä¸åˆ›å»ºæ–°èŠ‚ç‚¹
                    }
                }

                // åˆ›å»ºæç¤ºæ å…ƒç´ 
                const unlockIndicator = document.createElement('div');
                unlockIndicator.textContent = 'è§£é”äº†æ–°é”å®šèŠ‚ç‚¹' + NodeName;
                unlockIndicator.style.position = 'fixed';
                unlockIndicator.style.top = '100px';
                unlockIndicator.style.left = '50%';
                unlockIndicator.style.transform = 'translateX(-50%)';
                unlockIndicator.style.padding = '10px 20px';
                unlockIndicator.style.backgroundColor = '#52c41a';
                unlockIndicator.style.color = 'white';
                unlockIndicator.style.borderRadius = '4px';
                unlockIndicator.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.15)';
                unlockIndicator.style.zIndex = '1002';
                unlockIndicator.style.fontSize = '14px';
                unlockIndicator.style.fontWeight = '500';
                unlockIndicator.style.transition = 'opacity 0.3s';

                // æ·»åŠ åˆ°é¡µé¢ä¸­
                document.body.appendChild(unlockIndicator);

                // 3ç§’åè‡ªåŠ¨ç§»é™¤æç¤º
                setTimeout(() => {
                    unlockIndicator.style.opacity = '0';
                    setTimeout(() => {
                        document.body.removeChild(unlockIndicator);
                    }, 300);
                }, 3000);
            }

            // Add Locked Node Button
            function addLockedNode(LockNodeName) {
                // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨åŒåçš„é”å®šèŠ‚ç‚¹
                for (const [id, node] of nodes) {
                    if (node.locked && node.element.textContent === LockNodeName) {
                        console.log(`é”å®šèŠ‚ç‚¹ "${LockNodeName}" å·²å­˜åœ¨ï¼Œæ— éœ€é‡å¤åˆ›å»º`);
                        return; // å¦‚æœå·²å­˜åœ¨ï¼Œç›´æ¥è¿”å›ä¸åˆ›å»ºæ–°èŠ‚ç‚¹
                    }
                }

                // åœ¨è§†å£ä¸­å¿ƒåˆ›å»ºé”å®šèŠ‚ç‚¹
                const x = (canvasContainer.scrollLeft + canvasContainer.clientWidth / 2) / scale - 65;
                const y = (canvasContainer.scrollTop + canvasContainer.clientHeight / 2) / scale - 35;
                createNode(x, y, LockNodeName, true); // ä¼ é€’locked=true
            }

            // --- Node Creation with Overlap Avoidance ---
            function findNonOverlappingPosition(initialX, initialY, width = 130, height = 70) {
                const maxAttempts = 500;
                const step = Math.max(width, height) * 0.8;
                const searchRadius = step * 10;

                let candidateX = initialX;
                let candidateY = initialY;
                let isValid = false;
                let attempts = 0;

                const tempNode = { x: candidateX, y: candidateY, width: width, height: height };

                while (attempts < maxAttempts) {
                    isValid = true;
                    tempNode.x = candidateX;
                    tempNode.y = candidateY;

                    for (const [id, existingNode] of nodes) {
                        if (getOverlapArea(tempNode, existingNode) > 0) {
                            isValid = false;
                            break;
                        }
                    }

                    if (isValid) {
                        return { x: candidateX, y: candidateY };
                    }

                    const angle = attempts * 0.5;
                    const radius = (attempts * step) / 10;
                    candidateX = initialX + radius * Math.cos(angle);
                    candidateY = initialY + radius * Math.sin(angle);

                    attempts++;
                }

                console.warn("Could not find non-overlapping position after", maxAttempts, "attempts.");
                return { x: initialX, y: initialY };
            }

            function disclaimer() {
                // æ·»åŠ "ä»…ä¾›å‚è€ƒ"æç¤ºæ–‡æœ¬
                const disclaimer = document.createElement('div');
                disclaimer.innerHTML = 'ä»…ä¾›å‚è€ƒï¼Œè‹¥æ­¤é¡¹ç›®ä¸å¹¸æˆä¸ºæ•™æçš„ä¸€éƒ¨åˆ†</br>è¯·å‘å­¦ç”Ÿå¼ºè°ƒéœ€è¦è‡ªè¡Œæ€è€ƒå“ªäº›ã€é—®é¢˜ä¸ç»“è®ºã€‘é€‚åˆï¼Œå¹¶ä¿®æ”¹ä¸é€‚åˆçš„ã€é—®é¢˜ä¸ç»“è®ºã€‘';
                disclaimer.style.fontSize = '12px';
                disclaimer.style.color = 'gray';
                disclaimer.style.textAlign = 'center';
                disclaimer.style.marginTop = '10px';
                return disclaimer;
            }

            // --- ä¿®æ”¹ï¼šcreateNode å‡½æ•°å¢åŠ  locked å‚æ•° ---
            function createNode(x, y, text = 'æœªç¼–è¾‘èŠ‚ç‚¹', locked = false) {
                const nodeId = `node-${nodeIdCounter++}`;

                const finalPosition = findNonOverlappingPosition(x, y);
                const finalX = finalPosition.x;
                const finalY = finalPosition.y;

                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                if (locked) {
                    nodeElement.classList.add('locked'); // æ·»åŠ é”å®šæ ·å¼
                }
                nodeElement.id = nodeId;
                nodeElement.style.left = `${finalX}px`;
                nodeElement.style.top = `${finalY}px`;
                nodeElement.innerHTML = text;

                canvasContainer.appendChild(nodeElement);

                const nodeData = {
                    element: nodeElement,
                    id: nodeId,
                    x: finalX,
                    y: finalY,
                    width: nodeElement.offsetWidth,
                    height: nodeElement.offsetHeight,
                    isEditing: false,
                    locked: locked, // å­˜å‚¨é”å®šçŠ¶æ€
                    // æ–°å¢ï¼šä¸å¯ååº”å±æ€§
                    nonReactive: false // é»˜è®¤å¯ä»¥ååº”
                };

                nodes.set(nodeId, nodeData);
                makeNodeInteractive(nodeData);

                // æ·»åŠ æ–°èŠ‚ç‚¹ç‰¹æ•ˆ
                addNodeCreationEffect(nodeElement);

                return nodeData;
            }

            // åˆ›å»ºSWOTåˆ†æè¡¨æ ¼èŠ‚ç‚¹çš„å‡½æ•°
            function createSWOTNode(x, y, swotData) {
                const nodeId = `node-${nodeIdCounter++}`;
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.id = nodeId;

                const nodeElementChild = document.createElement('div');


                // åˆ›å»ºè¡¨æ ¼
                const table = document.createElement('table');
                table.classList.add('Editable');
                table.contentEditable = true;
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.fontSize = '12px';

                // åˆ›å»ºè¡¨å¤´
                const headerRow = document.createElement('tr');

                const th1 = document.createElement('th');
                th1.textContent = 'Strengths (ä¼˜åŠ¿)';
                th1.style.border = '1px solid #ddd';
                th1.style.padding = '8px';
                th1.style.backgroundColor = '#f2f2f2';

                const th2 = document.createElement('th');
                th2.textContent = 'Weaknesses (åŠ£åŠ¿)';
                th2.style.border = '1px solid #ddd';
                th2.style.padding = '8px';
                th2.style.backgroundColor = '#f2f2f2';

                headerRow.appendChild(th1);
                headerRow.appendChild(th2);

                // åˆ›å»ºç¬¬ä¸€è¡Œå†…å®¹
                const dataRow1 = document.createElement('tr');

                const td1 = document.createElement('td');
                // ä¿®æ”¹ä¸ºä½¿ç”¨<li>æ˜¾ç¤ºåˆ—è¡¨
                if (Array.isArray(swotData.strengths)) {
                    const div1 = document.createElement('div');
                    swotData.strengths.forEach(item => {
                        const divItem = document.createElement('div');
                        divItem.textContent = item;
                        divItem.className = 'no-label';
                        div1.appendChild(divItem);
                    });
                    td1.appendChild(div1);
                }
                td1.style.border = '1px solid #ddd';
                td1.style.padding = '8px';
                td1.style.verticalAlign = 'top';

                const td2 = document.createElement('td');
                // ä¿®æ”¹ä¸ºä½¿ç”¨<li>æ˜¾ç¤ºåˆ—è¡¨
                if (Array.isArray(swotData.weaknesses)) {
                    const div2 = document.createElement('div');
                    swotData.weaknesses.forEach(item => {
                        const divItem = document.createElement('div');
                        divItem.textContent = item;
                        divItem.className = 'no-label';
                        div2.appendChild(divItem);
                    });
                    td2.appendChild(div2);
                }
                td2.style.border = '1px solid #ddd';
                td2.style.padding = '8px';
                td2.style.verticalAlign = 'top';

                dataRow1.appendChild(td1);
                dataRow1.appendChild(td2);

                // åˆ›å»ºç¬¬äºŒè¡Œè¡¨å¤´
                const headerRow2 = document.createElement('tr');

                const th3 = document.createElement('th');
                th3.textContent = 'Opportunities (æœºä¼š)';
                th3.style.border = '1px solid #ddd';
                th3.style.padding = '8px';
                th3.style.backgroundColor = '#f2f2f2';

                const th4 = document.createElement('th');
                th4.textContent = 'Threats (å¨èƒ)';
                th4.style.border = '1px solid #ddd';
                th4.style.padding = '8px';
                th4.style.backgroundColor = '#f2f2f2';

                headerRow2.appendChild(th3);
                headerRow2.appendChild(th4);

                // åˆ›å»ºç¬¬äºŒè¡Œå†…å®¹
                const dataRow2 = document.createElement('tr');

                const td3 = document.createElement('td');
                // ä¿®æ”¹ä¸ºä½¿ç”¨<li>æ˜¾ç¤ºåˆ—è¡¨
                if (Array.isArray(swotData.opportunities)) {
                    const div3 = document.createElement('div');
                    swotData.opportunities.forEach(item => {
                        const divItem = document.createElement('div');
                        divItem.textContent = item;
                        divItem.className = 'no-label';
                        div3.appendChild(divItem);
                    });
                    td3.appendChild(div3);
                }
                td3.style.border = '1px solid #ddd';
                td3.style.padding = '8px';
                td3.style.verticalAlign = 'top';

                const td4 = document.createElement('td');
                // ä¿®æ”¹ä¸ºä½¿ç”¨<li>æ˜¾ç¤ºåˆ—è¡¨
                if (Array.isArray(swotData.threats)) {
                    const div4 = document.createElement('div');
                    swotData.threats.forEach(item => {
                        const divItem = document.createElement('div');
                        divItem.textContent = item;
                        divItem.className = 'no-label';
                        div4.appendChild(divItem);
                    });
                    td4.appendChild(div4);
                }
                td4.style.border = '1px solid #ddd';
                td4.style.padding = '8px';
                td4.style.verticalAlign = 'top';

                dataRow2.appendChild(td3);
                dataRow2.appendChild(td4);

                table.appendChild(headerRow);
                table.appendChild(dataRow1);
                table.appendChild(headerRow2);
                table.appendChild(dataRow2);
                nodeElementChild.appendChild(table);


                // è®¾ç½®èŠ‚ç‚¹æ ·å¼
                nodeElement.style.left = `${x}px`;
                nodeElement.style.top = `${y}px`;
                nodeElement.style.width = '600px';  // å›ºå®šå®½åº¦
                nodeElement.style.height = 'auto'; // å›ºå®šé«˜åº¦
                nodeElement.style.overflow = 'auto';


                nodeElementChild.appendChild(disclaimer());

                nodeElement.appendChild(nodeElementChild);

                canvasContainer.appendChild(nodeElement);

                const nodeData = {
                    element: nodeElement,
                    id: nodeId,
                    x: x,
                    y: y,
                    width: 600,   // å›ºå®šå®½åº¦
                    height: 'auto',  // å›ºå®šé«˜åº¦
                    isEditing: false,
                    locked: true, // ä¿®æ”¹ï¼šSWOTèŠ‚ç‚¹é»˜è®¤é”å®šä¸å¯ç¼–è¾‘
                    // æ–°å¢ï¼šSWOTèŠ‚ç‚¹é»˜è®¤ä¸å¯ååº”
                    nonReactive: true
                };

                nodes.set(nodeId, nodeData);
                makeNodeInteractive(nodeData);

                return nodeData;
            }

            // åˆ›å»ºSTPåˆ†æè¡¨æ ¼èŠ‚ç‚¹çš„å‡½æ•°
            function createSTPNode(x, y, stpData) {
                const nodeId = `node-${nodeIdCounter++}`;
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.id = nodeId;

                const nodeElementChild = document.createElement('div');

                // åˆ›å»ºè¡¨æ ¼
                const table = document.createElement('table');
                table.classList.add('Editable');
                table.contentEditable = true;
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.fontSize = '12px';

                // å°è£…åˆ›å»ºåˆ—è¡¨å…ƒç´ çš„å‡½æ•°
                function createListElement(dataArray) {
                    const container = document.createElement('td');
                    if (Array.isArray(dataArray)) {
                        // æ£€æŸ¥æ˜¯å¦ä¸ºå­—å…¸åˆ—è¡¨
                        if (dataArray.length > 0 && typeof dataArray[0] === 'object' && dataArray[0] !== null) {
                            // å¤„ç†å­—å…¸åˆ—è¡¨
                            const listContainer = document.createElement('div');
                            dataArray.forEach(item => {
                                const itemDiv = document.createElement('div');
                                itemDiv.className = 'no-label';
                                // å°†å­—å…¸å¯¹è±¡è½¬æ¢ä¸ºå¯è¯»æ–‡æœ¬
                                // let itemText = '<div class="folded-corner-card">'
                                let itemText = `<div class="MultiCard">`
                                itemText += Object.entries(item).map(([key, value]) => `<div><strong>${key} </strong>- ${value}</div>`).join('');
                                itemText += '</div>'
                                itemDiv.innerHTML = itemText;
                                listContainer.appendChild(itemDiv);
                            });
                            container.appendChild(listContainer);
                        } else {
                            // å¤„ç†æ™®é€šå­—ç¬¦ä¸²åˆ—è¡¨
                            const listContainer = document.createElement('div');
                            dataArray.forEach(item => {
                                const itemDiv = document.createElement('div');
                                itemDiv.textContent = item;
                                itemDiv.className = 'no-label';
                                listContainer.appendChild(itemDiv);
                            });
                            container.appendChild(listContainer);
                        }
                    }
                    container.style.border = '1px solid #ddd';
                    container.style.padding = '8px';
                    container.style.verticalAlign = 'top';
                    return container;
                }

                // åˆ›å»ºè¡¨å¤´è¡Œ
                const headerRow = document.createElement('tr');

                const th1 = document.createElement('th');
                th1.textContent = 'Segmentation (å¸‚åœºç»†åˆ†)';
                th1.style.border = '1px solid #ddd';
                th1.style.padding = '8px';
                th1.style.backgroundColor = '#f2f2f2';

                const th2 = document.createElement('th');
                th2.textContent = 'Targeting (ç›®æ ‡é€‰æ‹©)';
                th2.style.border = '1px solid #ddd';
                th2.style.padding = '8px';
                th2.style.backgroundColor = '#f2f2f2';

                headerRow.appendChild(th1);
                headerRow.appendChild(th2);
                table.appendChild(headerRow);

                // åˆ›å»ºç¬¬ä¸€è¡Œå†…å®¹
                const dataRow1 = document.createElement('tr');

                // ä½¿ç”¨å°è£…çš„å‡½æ•°åˆ›å»ºåˆ—è¡¨å…ƒç´ 
                const td1 = createListElement(stpData.segmentation);
                const td2 = createListElement(stpData.targeting);

                dataRow1.appendChild(td1);
                dataRow1.appendChild(td2);
                table.appendChild(dataRow1);

                // åˆ›å»ºç¬¬äºŒè¡Œè¡¨å¤´
                const headerRow2 = document.createElement('tr');

                const th3 = document.createElement('th');
                th3.textContent = 'Positioning (å¸‚åœºå®šä½)';
                th3.style.border = '1px solid #ddd';
                th3.style.padding = '8px';
                th3.style.backgroundColor = '#f2f2f2';
                th3.colSpan = 2; // è·¨ä¸¤åˆ—

                headerRow2.appendChild(th3);
                table.appendChild(headerRow2);

                // åˆ›å»ºç¬¬äºŒè¡Œå†…å®¹
                const dataRow2 = document.createElement('tr');

                // ä½¿ç”¨å°è£…çš„å‡½æ•°åˆ›å»ºåˆ—è¡¨å…ƒç´ 
                const td3 = createListElement(stpData.positioning);
                td3.colSpan = 2; // è·¨ä¸¤åˆ—

                dataRow2.appendChild(td3);
                table.appendChild(dataRow2);

                nodeElementChild.appendChild(table);

                // è®¾ç½®èŠ‚ç‚¹æ ·å¼
                nodeElement.style.left = `${x}px`;
                nodeElement.style.top = `${y}px`;
                nodeElement.style.width = '800px';  // å›ºå®šå®½åº¦
                nodeElement.style.height = 'auto'; // å›ºå®šé«˜åº¦
                nodeElement.style.overflow = 'auto';


                nodeElementChild.appendChild(disclaimer());

                nodeElement.appendChild(nodeElementChild);

                canvasContainer.appendChild(nodeElement);

                const nodeData = {
                    element: nodeElement,
                    id: nodeId,
                    x: x,
                    y: y,
                    width: 800,   // å›ºå®šå®½åº¦
                    height: 'auto',  // å›ºå®šé«˜åº¦
                    isEditing: false,
                    locked: true, // ä¿®æ”¹ï¼šSTPèŠ‚ç‚¹é»˜è®¤é”å®šä¸å¯ç¼–è¾‘
                    // STPèŠ‚ç‚¹é»˜è®¤ä¸å¯ååº”
                    nonReactive: true
                };

                nodes.set(nodeId, nodeData);
                makeNodeInteractive(nodeData);

                return nodeData;
            }

            // åˆ›å»ºç«å“åˆ†æè¡¨æ ¼èŠ‚ç‚¹çš„å‡½æ•°
            function createCompetitiveAnalysisNode(x, y, competitiveData) {
                const nodeId = `node-${nodeIdCounter++}`;
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.id = nodeId;

                const nodeElementChild = document.createElement('div');

                // åˆ›å»ºè¡¨æ ¼
                const table = document.createElement('table');
                table.classList.add('Editable');
                table.contentEditable = true;
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.fontSize = '12px';

                // å°è£…åˆ›å»ºåˆ—è¡¨å…ƒç´ çš„å‡½æ•°
                function createListElement(dataArray) {
                    const container = document.createElement('td');
                    if (Array.isArray(dataArray)) {
                        // å¤„ç†æ™®é€šå­—ç¬¦ä¸²åˆ—è¡¨
                        const listContainer = document.createElement('div');
                        listContainer.className = 'MultiCard';
                        dataArray.forEach(item => {
                            const itemDiv = document.createElement('div');
                            itemDiv.textContent = item;
                            itemDiv.className = 'no-label';
                            listContainer.appendChild(itemDiv);
                        });
                        container.appendChild(listContainer);
                    }
                    container.style.border = '1px solid #ddd';
                    container.style.padding = '8px';
                    container.style.verticalAlign = 'top';
                    return container;
                }

                // åˆ›å»ºè¡¨å¤´
                const headerRow = document.createElement('tr');

                const th1 = document.createElement('th');
                th1.textContent = 'åˆ†æç»´åº¦ä¸¾ä¾‹';
                th1.style.border = '1px solid #ddd';
                th1.style.padding = '8px';
                th1.style.backgroundColor = '#f2f2f2';
                th1.style.width = '30%';

                const th2 = document.createElement('th');
                th2.textContent = 'ç«å“åˆ†æä¸¾ä¾‹ï¼ˆå‚è€ƒï¼‰';
                th2.style.border = '1px solid #ddd';
                th2.style.padding = '8px';
                th2.style.backgroundColor = '#f2f2f2';

                headerRow.appendChild(th1);
                headerRow.appendChild(th2);
                table.appendChild(headerRow);

                // ä¸ºæ¯ä¸ªé”®å€¼å¯¹åˆ›å»ºä¸€è¡Œ
                Object.entries(competitiveData).forEach(([key, value]) => {
                    const dataRow = document.createElement('tr');

                    const keyCell = document.createElement('td');
                    keyCell.textContent = key;
                    keyCell.style.border = '1px solid #ddd';
                    keyCell.style.padding = '10px';
                    keyCell.style.verticalAlign = 'middle';
                    keyCell.style.fontWeight = 'bold';

                    const valueCell = createListElement(value);

                    dataRow.appendChild(keyCell);
                    dataRow.appendChild(valueCell);
                    table.appendChild(dataRow);
                });

                nodeElementChild.appendChild(table);

                // è®¾ç½®èŠ‚ç‚¹æ ·å¼
                nodeElement.style.left = `${x}px`;
                nodeElement.style.top = `${y}px`;
                nodeElement.style.width = '600px';
                nodeElement.style.height = 'auto';
                nodeElement.style.overflow = 'auto';

                nodeElementChild.appendChild(disclaimer());

                nodeElement.appendChild(nodeElementChild);

                canvasContainer.appendChild(nodeElement);

                const nodeData = {
                    element: nodeElement,
                    id: nodeId,
                    x: x,
                    y: y,
                    width: 600,
                    height: 'auto',
                    isEditing: false,
                    locked: true,
                    nonReactive: true
                };
                nodes.set(nodeId, nodeData);
                makeNodeInteractive(nodeData);

                return nodeData;
            }

            // åˆ›å»ºCMFåˆ†æè¡¨æ ¼èŠ‚ç‚¹çš„å‡½æ•°
            function createCMFNode(x, y, cmfData) {
                const nodeId = `node-${nodeIdCounter++}`;
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.id = nodeId;

                const nodeElementChild = document.createElement('div');

                // åˆ›å»ºè¡¨æ ¼
                const table = document.createElement('table');
                table.classList.add('Editable');
                table.contentEditable = true;
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.fontSize = '12px';

                // å°è£…åˆ›å»ºåˆ—è¡¨å…ƒç´ çš„å‡½æ•°
                function createListElement(dataArray) {
                    const container = document.createElement('td');
                    if (Array.isArray(dataArray)) {
                        // æ£€æŸ¥æ˜¯å¦ä¸ºå­—å…¸åˆ—è¡¨
                        if (dataArray.length > 0 && typeof dataArray[0] === 'object' && dataArray[0] !== null) {
                            // å¤„ç†å­—å…¸åˆ—è¡¨
                            const listContainer = document.createElement('div');
                            dataArray.forEach(item => {
                                const itemDiv = document.createElement('div');
                                itemDiv.className = 'no-label';
                                // å°†å­—å…¸å¯¹è±¡è½¬æ¢ä¸ºå¯è¯»æ–‡æœ¬
                                // let itemText = '<div class="folded-corner-card">'
                                let itemText = `<div class="MultiCard">`
                                itemText += Object.entries(item).map(([key, value]) => `<div><strong>${key} </strong>- ${value}</div>`).join('');
                                itemText += '</div>'
                                itemDiv.innerHTML = itemText;
                                listContainer.appendChild(itemDiv);
                            });
                            container.appendChild(listContainer);
                        } else {
                            // å¤„ç†æ™®é€šå­—ç¬¦ä¸²åˆ—è¡¨
                            const listContainer = document.createElement('div');
                            dataArray.forEach(item => {
                                const itemDiv = document.createElement('div');
                                itemDiv.textContent = item;
                                itemDiv.className = 'no-label';
                                listContainer.appendChild(itemDiv);
                            });
                            container.appendChild(listContainer);
                        }
                    }
                    container.style.border = '1px solid #ddd';
                    container.style.padding = '8px';
                    container.style.verticalAlign = 'top';
                    return container;
                }


                // åˆ›å»ºCMFä¸‰è¡Œå†…å®¹
                // ç¬¬ä¸€è¡Œï¼šé¢œè‰²
                const colorRow = document.createElement('tr');

                const colorHeader = document.createElement('th');
                colorHeader.textContent = 'Color (é¢œè‰²)';
                colorHeader.style.border = '1px solid #ddd';
                colorHeader.style.padding = '8px';
                colorHeader.style.backgroundColor = '#f2f2f2';
                colorHeader.style.width = '20%';

                const colorContent = createListElement(cmfData.color);

                colorRow.appendChild(colorHeader);
                colorRow.appendChild(colorContent);
                table.appendChild(colorRow);

                // ç¬¬äºŒè¡Œï¼šæè´¨
                const materialRow = document.createElement('tr');

                const materialHeader = document.createElement('th');
                materialHeader.textContent = 'Material (æè´¨)';
                materialHeader.style.border = '1px solid #ddd';
                materialHeader.style.padding = '8px';
                materialHeader.style.backgroundColor = '#f2f2f2';
                materialHeader.style.width = '20%';

                const materialContent = createListElement(cmfData.material);

                materialRow.appendChild(materialHeader);
                materialRow.appendChild(materialContent);
                table.appendChild(materialRow);

                // ç¬¬ä¸‰è¡Œï¼šè¡¨é¢å¤„ç†å·¥è‰º
                const finishingRow = document.createElement('tr');

                const finishingHeader = document.createElement('th');
                finishingHeader.textContent = 'Finishing (è¡¨é¢å¤„ç†å·¥è‰º)';
                finishingHeader.style.border = '1px solid #ddd';
                finishingHeader.style.padding = '8px';
                finishingHeader.style.backgroundColor = '#f2f2f2';
                finishingHeader.style.width = '20%';

                const finishingContent = createListElement(cmfData.finishing);

                finishingRow.appendChild(finishingHeader);
                finishingRow.appendChild(finishingContent);
                table.appendChild(finishingRow);

                nodeElementChild.appendChild(table);

                // è®¾ç½®èŠ‚ç‚¹æ ·å¼
                nodeElement.style.left = `${x}px`;
                nodeElement.style.top = `${y}px`;
                nodeElement.style.width = '600px';  // å›ºå®šå®½åº¦
                nodeElement.style.height = 'auto'; // å›ºå®šé«˜åº¦
                nodeElement.style.overflow = 'auto';

                nodeElementChild.appendChild(disclaimer());

                nodeElement.appendChild(nodeElementChild);

                canvasContainer.appendChild(nodeElement);

                const nodeData = {
                    element: nodeElement,
                    id: nodeId,
                    x: x,
                    y: y,
                    width: 600,   // å›ºå®šå®½åº¦
                    height: 'auto',  // å›ºå®šé«˜åº¦
                    isEditing: false,
                    locked: true, // CMFèŠ‚ç‚¹é»˜è®¤é”å®šä¸å¯ç¼–è¾‘
                    // CMFèŠ‚ç‚¹é»˜è®¤ä¸å¯ååº”
                    nonReactive: true
                };

                nodes.set(nodeId, nodeData);
                makeNodeInteractive(nodeData);

                return nodeData;
            }

            // åˆ›å»ºPESTåˆ†æè¡¨æ ¼èŠ‚ç‚¹çš„å‡½æ•°
            function createPESTNode(x, y, pestData) {
                const nodeId = `node-${nodeIdCounter++}`;
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.id = nodeId;

                const nodeElementChild = document.createElement('div');

                // åˆ›å»ºè¡¨æ ¼
                const table = document.createElement('table');
                table.classList.add('Editable');
                table.contentEditable = true;
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.fontSize = '12px';

                // åˆ›å»ºè¡¨å¤´
                const headerRow = document.createElement('tr');

                const th1 = document.createElement('th');
                th1.textContent = 'Political (æ”¿æ²»)';
                th1.style.border = '1px solid #ddd';
                th1.style.padding = '8px';
                th1.style.backgroundColor = '#f2f2f2';

                const th2 = document.createElement('th');
                th2.textContent = 'Economic (ç»æµ)';
                th2.style.border = '1px solid #ddd';
                th2.style.padding = '8px';
                th2.style.backgroundColor = '#f2f2f2';

                headerRow.appendChild(th1);
                headerRow.appendChild(th2);

                // åˆ›å»ºç¬¬ä¸€è¡Œå†…å®¹
                const dataRow1 = document.createElement('tr');

                const td1 = document.createElement('td');
                // ä¿®æ”¹ä¸ºä½¿ç”¨<div>æ˜¾ç¤ºåˆ—è¡¨
                if (Array.isArray(pestData.Political)) {
                    const div1 = document.createElement('div');
                    pestData.Political.forEach(item => {
                        const divItem = document.createElement('div');
                        divItem.textContent = item;
                        divItem.className = 'no-label MultiCard';
                        div1.appendChild(divItem);
                    });
                    td1.appendChild(div1);
                }
                td1.style.border = '1px solid #ddd';
                td1.style.padding = '8px';
                td1.style.verticalAlign = 'top';

                const td2 = document.createElement('td');
                // ä¿®æ”¹ä¸ºä½¿ç”¨<div>æ˜¾ç¤ºåˆ—è¡¨
                if (Array.isArray(pestData.Economic)) {
                    const div2 = document.createElement('div');
                    pestData.Economic.forEach(item => {
                        const divItem = document.createElement('div');
                        divItem.textContent = item;
                        divItem.className = 'no-label';
                        div2.appendChild(divItem);
                    });
                    td2.appendChild(div2);
                }
                td2.style.border = '1px solid #ddd';
                td2.style.padding = '8px';
                td2.style.verticalAlign = 'top';

                dataRow1.appendChild(td1);
                dataRow1.appendChild(td2);

                // åˆ›å»ºç¬¬äºŒè¡Œè¡¨å¤´
                const headerRow2 = document.createElement('tr');

                const th3 = document.createElement('th');
                th3.textContent = 'Social (ç¤¾ä¼š)';
                th3.style.border = '1px solid #ddd';
                th3.style.padding = '8px';
                th3.style.backgroundColor = '#f2f2f2';

                const th4 = document.createElement('th');
                th4.textContent = 'Technological (æŠ€æœ¯)';
                th4.style.border = '1px solid #ddd';
                th4.style.padding = '8px';
                th4.style.backgroundColor = '#f2f2f2';

                headerRow2.appendChild(th3);
                headerRow2.appendChild(th4);

                // åˆ›å»ºç¬¬äºŒè¡Œå†…å®¹
                const dataRow2 = document.createElement('tr');

                const td3 = document.createElement('td');
                if (Array.isArray(pestData.Social)) {
                    const div3 = document.createElement('div');
                    pestData.Social.forEach(item => {
                        const divItem = document.createElement('div');
                        divItem.textContent = item;
                        divItem.className = 'no-label MultiCard';
                        div3.appendChild(divItem);
                    });
                    td3.appendChild(div3);
                }
                td3.style.border = '1px solid #ddd';
                td3.style.padding = '8px';
                td3.style.verticalAlign = 'top';

                const td4 = document.createElement('td');
                if (Array.isArray(pestData.Technological)) {
                    const div4 = document.createElement('div');
                    pestData.Technological.forEach(item => {
                        const divItem = document.createElement('div');
                        divItem.textContent = item;
                        divItem.className = 'no-label';
                        div4.appendChild(divItem);
                    });
                    td4.appendChild(div4);
                }
                td4.style.border = '1px solid #ddd';
                td4.style.padding = '8px';
                td4.style.verticalAlign = 'top';

                dataRow2.appendChild(td3);
                dataRow2.appendChild(td4);

                table.appendChild(headerRow);
                table.appendChild(dataRow1);
                table.appendChild(headerRow2);
                table.appendChild(dataRow2);
                nodeElementChild.appendChild(table);

                // è®¾ç½®èŠ‚ç‚¹æ ·å¼
                nodeElement.style.left = `${x}px`;
                nodeElement.style.top = `${y}px`;
                nodeElement.style.width = '600px';  // å›ºå®šå®½åº¦
                nodeElement.style.height = 'auto'; // å›ºå®šé«˜åº¦
                nodeElement.style.overflow = 'auto';

                // æ·»åŠ "ä»…ä¾›å‚è€ƒ"æç¤ºæ–‡æœ¬
                const disclaimer = document.createElement('div');
                disclaimer.innerHTML = 'ä»…ä¾›å‚è€ƒï¼Œè‹¥ä¸å¹¸æˆä¸ºæ•™æçš„ä¸€éƒ¨åˆ†</br>è¯·å‘å­¦ç”Ÿå¼ºè°ƒéœ€è¦è‡ªè¡Œæ€è€ƒè¿‡å“ªäº›ç»“è®ºé€‚åˆï¼Œå¹¶ä¿®æ”¹ä¸é€‚åˆçš„ç»“è®º';
                disclaimer.style.fontSize = '12px';
                disclaimer.style.color = 'gray';
                disclaimer.style.textAlign = 'center';
                disclaimer.style.marginTop = '10px';
                nodeElementChild.appendChild(disclaimer);

                nodeElement.appendChild(nodeElementChild);

                canvasContainer.appendChild(nodeElement);

                const nodeData = {
                    element: nodeElement,
                    id: nodeId,
                    x: x,
                    y: y,
                    width: 600,   // å›ºå®šå®½åº¦
                    height: 'auto',  // å›ºå®šé«˜åº¦
                    isEditing: false,
                    locked: true, // ä¿®æ”¹ï¼šPESTèŠ‚ç‚¹é»˜è®¤é”å®šä¸å¯ç¼–è¾‘
                    // PESTèŠ‚ç‚¹é»˜è®¤ä¸å¯ååº”
                    nonReactive: true
                };

                nodes.set(nodeId, nodeData);
                makeNodeInteractive(nodeData);

                return nodeData;
            }

            function createUserMapNode(x, y, UserMapData) {
                const nodeId = `node-${nodeIdCounter++}`;
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.id = nodeId;
                const nodeElementChild = document.createElement('div');
                const nonePIC = 'data:image/webp;base64,UklGRsAOAABXRUJQVlA4ILQOAABQXwGdASo4BDgEPr1erlCnJaSioTIYQOAXiWlu4XdEhmPvtEL6mHcbrkCxHZmpg7zoEt1gCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wC6moCYxC4wCiaihAdkW+j8LVyYSW9x1gCYxC4wC6moCYxC4wC6moCYxC4wC6moCXiC8Uk1oZ+mMQuMAupqAmMQuMAupqAmMQuMAupqAmMP45w+6BgERwKfSLH3Ora/kQh0IEYC6moCYxC4wC6moCYxC4wC6moCYxC4wCiGwmxW3OsYDGEYLNJMqsweSITDiM1fB1masATGIXGAXU1ATGIXGAXU1ATGIXGAXU0UydGBPFRssYDHjxARpGP9VRxhiBsrdK4aD4xYCBFGJFQPQhcYBdTUBMYhcYBdTUBMYhcYBdTUBMYhTLVhgR7I+NLAc8qNaD4DAVQ9JfJ/5qDzMQ6E8q5jELjALqagJjELjALqagJjELjALqagMmn8gvTMNl4QPsUPTZpAYH2wC9ATGIXGAXU1ATGIXGAXU1ATGIXGAXU08jSTnzJCyA3aCohcYk1nMt7jrAExiFxgF1NQExiFxgF1NQExg5OUDLZ1eSeCZcxi6moCYxH2lMt7jrAExiFxgF1NQExiFxgF1NQEwqKA87iCX77ZIWCK5yIzN7jrAcqSfEW2mW9x1gCYxC4wC6moCYxC4wC6moQyFjELjEtznFVgCYxC4wC6moCYxC4wC6moCYxC4wC6migkW8otPJV/43UI1a/r33vlWvTlwMrrAExiFxgF1NQExiFxgF1NFs1hnW1a96teSOCCHPvsHZZRJd5KuYuJwb6T5wpMPgAktPF607bA6QXgUlyjEEIPDn73m4xj+4zWAJjELjALqagJjELjALpuyr+Ndt+GpepsZGYwxIRlmkxDw1il5Af9m1NPIL6G5EODIAFt1ZJF0iVONcoxIduULjFP89FLcohajwYmGKoJqAmMQuMAupqAmMQuL/sALz1LlBqL2PMYhcnUqYPMNyKJNTy/Oec5DlBWOzQ3fi/JznFzPMgOXnw1iM0sJK6wBMYhcYBdTUBMYhbk5wwkE6b3xJb3HWAJiq/1EkDkmPZSOuRxNVCQVxrbpLM55iPxL5dKFxgF1NQExiFxgF1NFL6lOzcRqagJjELjAKKDrFvlhTmUsscjuPDnHCrWbS06ExiFxgF1NQExiFxgFxGRwWrcashmd1NQExiFxf9L6s8xVHW7viLJYkK45LSYcffFtplvcdYAmMQuMAupp5IYkzWDPfW9x1gCYxC4vQ7o7xoUAu9SagYmQnemMQuMAupqAmMQuL/sASRI8+k0d6YxC4wC6moCXiEHwk8D0BMYhcYBdTUBMYhcYBdTUBLxMDywHEO9MYhcYBdTUBMVGwXCcOoc2OsATGIXGAXU1ATGIXGAXUtcFL+5BHWAJjELjALqagJeFlX2rpvcdYAmMQuMAupqAmMQuMAorvlrCPze46wBMYhcYBdTTyb/q5xEbE70xiFxgF1NQExiFxgF1NFW1XrpTXGAXU1ATGIXGAXTffmPNLkYBdTUBMYhcYBdTUBMYhboaKZbCAupqAmMQuMAupqAiw28FzplvcdYAmMQuMAupqAmMQtz1u9Y8/gCYxC4wC6moCYxC3P/4yYsAupqAmMQuMAupqAmMQuL0+on6wBMYhcYBdTUBMYhTsK7/NmmMQuMAupqAmMQuMAupp//Ow38eYxC4wC6moCYxC4nqKzsk1ATGIXGAXU1ATGIXGAXTec1Tx1gCYxC4wC6moCYqj7/Zb3HWAJjELjALqagJjELieiibfIF1NQExiFxgF1NQEvLSQIfE70xiFxgF1NQExiFxgF1EGOrl1opF1NQExiFxgF1NQEvMmcYEigLqagJjELjALqagJjELjAKPaym57umW9x1gCYxC4wC6lsjQmR3pMYhcYBdTUBMYhcYBdTUBFNbWzqbTLe46wBMYhcYBcUZfL9gwrrAExiFxgF1NQExiFxgF03rSljzmi20y3uOsATGIXF6Mrbu7HtMt7jrAExiFxgF1NQExiFydLVHzGTe6wBMYhcYBdTUBFcCKE37PHWAJjELjALqagJjELjALqWjGWGqAM98TvTGIXGAXU0/+qKCPV/TLe46wBMYhcYBdTUBMYhcYBcRPbu9ZD5j0xiFxgF1NQEvCr14mMUNQExiFxgF1NQExiFxgF1NQExmI9pQQ6DJUYhcYBdTUBMVDWsnZO49x1gCYxC4wC6moCYxC4wC6moCdC6dCHGxzAxj0xiFxgF1NFJkJs5PHK0xiFxgF1NQExiFxgF1NQExiFxgjYoHqfJQWFNe46wBMYhbkwtn/LCjvre46wBMYhcYBdTUBMYhcYBdTUBLw/f15kPMmrs+oCYxC4nERk8m2NQExiFxgF1NQExiFxgF1NQExiFxgGF/Nu4218iSuxVS7xO9F0bfq2GXfsCf5e7aZb3HWAJjELjALqagJjELjALqagJjELc0jOFVw9cXqR+taUbxMTHxa64mY4jdMj3wc0T1JYAmMQuMAupqAmMQuMAupqAmMQuMAupqAmMQuVKQF1NQExiFxgF1NQExiFxgF1NQExiFxgF1NQExiFxgF1NQExiFxgF1NQExiFxgF1NQExh/tbnqCW/LakvxkGmBWQaYFZBpgVkGmBWQaYFZBpgVkCfnLIKeIwWioP5AaqehCr8sKwBMYhcYBdTUBMYhcYBdNk14wK/+WsYvTUkuMAupqAmMQuMGg8FO1x1tgrgFsjLjC/vTGIXGAXU1ATGIXGAUdSI1J//oz67UMgCYxC4wC6moCYxC4wRzbLSchVX6PeAupqAmMQuMAupqAmKiF4XSZP7GAXU1ATGIXGAXU1ATGIUzQcM/fop6rO6moCYxC4wC6moCXhV6rZ8W++LbTLe46wBMYhcYBdTUBMVTwZB3n+N3C6moCYxC4wC6mnkhopEjJ2q8xiFxgF1NQExiFxgF1NQExg6FIM01/YC6moCYxC4wC6boDZyy8wdtMt7jrAExiFxgF1NQExiFxflpIlnE1zLbTLe46wBMYhbllflT4dYAmMQuMAupqAmMQuMAupqAmKiDAmQzVeoxC4wC6moCYqcFME37PHWAJjELjALqagJjELjALqagIp+a/7FWAXU1ATGIXF6LqNGPIrAExiFxgF1NQExiFxgF1NQExh/fJNtHqyHUlXMXGAXU0//wNSAhUmMQuMAupqAmMQuMAupqAmMQuL1CSMxlfELjALqagJjB9dvCD0zGIXGAXU1ATGIXGAXU1ATGIXF/2M9SJAIwC6moCYxC3R4yusATGIXGAXU1ATGIXGAXU1ATGD0ZyTLjALqagJjEG++FEhdlkTvTGIXGAXU1ATGIXGAXU1ATGH954OOYuMAupqAmKo1gIm9MYhcYBdTUBMYhcYBdTUBMYhcT10vEgUt7jrAExiFugEcBZE70xiFxgF1NQExiFxgF1NQExiFOxs3sLjALqagJjB75XhmMQuMAupqAmMQuMAupqAmMQuMAo95m3U1ATGIXGAUfr8OhgF1NQExiFxgF1NQExiFxgF1NQCsrJsKLAExiFxgF03w2YuNrbTLe46wBMYhcYBdTUBMYhcYBdS252W9x0gAAD+/20qcAJ5QAAAAAAAF7e9FPB6d5aDnaEPJlmZencbM7FvO3ldxqufsHMMsdB1n8beyQEzjXIRIdwdQC3o1GeJTjBmXmVwJArwBS2rr/niW7HsMrWnMhQHoD/UntjTPozS4UgvtXuSIDRDVypdQtAJI3R0AoEk8l2MQDsngUIW1Ihs52Mv8fNqiKY0yNklNgQZ53V0USIJXfA25qk/5PkxgHhVfjjnUDgxgY2SiaLPvVC8JnBFXrJ5XdpEC9+VAM2rRC7Y60DzzyDVO3NQYwINBXAFFI6x+kBil205ra4ilfO5s8l4dcrdGLndepX4aLWmMfTPfgPr2snO9faW5EOwyeUFAntG48Ai4t4kpid6A4GASs1Bo3B4PpDyOFos90tTrwIRThcZBp/YGnHwoBc9YFP3DR4i9XX/bGeXGwciXLNojYEWv4e64GpNgaaWyrsD/4w0gOzD9+BASVhBdUYFMyNje8yKZoQ5u2WZDemTCeGX0UCAAA+RlJmSZ0kfQUFHWP49WGMDo1y2iwYYJlhCunOzTJkPEoErdLxAbsil8yvmuyaqTHBLkzaaOnIJADQSe6pcFcElFde0obpZ6yZZisN/m421fFDMlECVN9+UcHULqO1mu8T5Xcl+DxJoqQflq1yLDMKCSwYYQNJaxJyIY2Mpz2/enHX5w9ftvVEEgi/lVzsbCiTfjOpX1nURe0MUaEqlKcPRS0Z7z4x3KSQxq0tYVOkeLDpR+zBZLaTdtWP7zcCFZROBskRTiU+MpJdG+IXNpdRj+aECJLZcR1kfzEXrzPe7FqBuPopsSgCpn40EDFCoTH8z8XEoCPFAnoAAAABK8vZYDvUACQQACIZ0AAAAB4ECqw2ZefhgikAjuAAfVI84aoeJwYEvFDy39sBfCAABMcMKFL03OL289ewDiQOMeAADWb5zJEAAQbnJAAisyagWBxqpbIr7WSmKACvsfetHbAAbwCftekA2J/mwcgAADIm1TJeIwhGJu6Ic3k6SAJ5L6wxmv8eR0pXfReTOzSMKAcBwAkNfdyJFEFlqqMAQaWL0xviFAAAAACcdRCAOokfgJAXSLaDMFuBeYrXEaIAD6Ired95Bv6ZwF7hmPgAAM+geI0hm2stAJ5Bs8X1nms6sQqkDYR4tkn2NBpeImrKC+kgAbz8B3eAAAAACAd4lIAApPA0CAA5CABB5EC2HB+LBdY2AFrHkW2dRIOVAAJzDbcgwBAGRyJMiaBeZ1EeAIg20ADNMNqVHMwAAAA=='
                // ${ Object.entries(UserMapData.ä¸ªäººä¿¡æ¯).map(([key, value]) => `<div><strong>${key}</strong>: ${value}</div>`).join('') }
                nodeElementChild.innerHTML = `
                <table class="Editable" contenteditable="true" style="border: 1px solid #000;padding: 10px;text-align: center;">
                    <tr>
                        <td style="border-right:  3px solid #999;padding: 10px;"  valign="top">
                            <table>
                                <tr>
                                    <td style="text-align: right;font-size:large;margin-bottom: 20px;"><strong>${UserMapData.äººç‰©åå­—}</strong></td>
                                </tr>
                                <tr>
                                <tr>
                                    <td style="text-align: left;"><img width=120 height=120 src='${nonePIC}' title="" /></td>
                                </tr>
                                <tr>
                                    <td style="text-align: left;"><br>ä¸ªäººä¿¡æ¯</td>
                                </tr>
                                <tr>
                                    <td style="text-align: left;min-width:120px">
                                        <div><strong>èŒä¸š</strong>: ${UserMapData.ä¸ªäººä¿¡æ¯èŒä¸š}</div>
                                        <div><strong>å¹´é¾„</strong>: ${UserMapData.ä¸ªäººä¿¡æ¯å¹´é¾„}</div>
                                        <div><strong>å±…ä½åœ°</strong>: ${UserMapData.ä¸ªäººä¿¡æ¯å±…ä½åœ°}</div>
                                        <div><strong>å®¶åº­</strong>: ${UserMapData.ä¸ªäººä¿¡æ¯å®¶åº­}</div>
                                        <div><strong>çˆ±å¥½</strong>: ${UserMapData.ä¸ªäººä¿¡æ¯çˆ±å¥½}</div>
                                    </td>
                                </tr>
                            </table>
                        </td>
                        <td valign="top">
                            <table>
                                <tr>
                                    <td>
                                        <table style="text-align: left;padding: 10px;">
                                            <tr>
                                                <td style='font-size: larger;font-weight: bold;'>${UserMapData.å…³é”®ç‰¹å¾ä¸æ¦‚è¿°ä¸€å¥è¯æ€»ç»“ç”¨æˆ·ç›®æ ‡}</td>
                                            </tr>
                                            <tr>
                                                <td style="text-indent: 30px;"><br>${UserMapData.å…³é”®ç‰¹å¾ä¸æ¦‚è¿°ç”¨æˆ·è¯¦ç»†æ•…äº‹}</td>
                                            </tr>
                                        </table>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <table style="text-align: left;padding: 10px;">
                                            <tr>
                                                <td style="color: #b02875;">ç”¨æˆ·ç›®æ ‡</td>
                                                <td style="color: #b02875;">äº§å“ä¸å“ç‰Œæ€åº¦</td>
                                                <td style="color: #b02875;">çŸ¥è¯†å’Œç»éªŒ</td>
                                                <td style="color: #b02875;">ä¿¡æ¯æ¸ é“</td>
                                            </tr>
                                            <tr>
                                                <td valign="top" style='min-width:100px;width:25%;border-right:1px soild #ccc' id="Upgoals">${UserMapData.äº§å“è®¤çŸ¥ä¸æ€åº¦ç”¨æˆ·ç›®æ ‡.map((value) => `<div>${value}</div>`).join('')}</td>
                                                <td valign="top" style='min-width:100px;width:25%;border-right:1px soild #ccc' id="Productandbrandattitude">${UserMapData.äº§å“è®¤çŸ¥ä¸æ€åº¦äº§å“ä¸å“ç‰Œæ€åº¦.map((value) => `<div>${value}</div>`).join('')}</td>
                                                <td valign="top" style='min-width:100px;width:25%;border-right:1px soild #ccc' id="Knowledgeandexperience">${UserMapData.äº§å“è®¤çŸ¥ä¸æ€åº¦çŸ¥è¯†ç»éªŒ.map((value) => `<div>${value}</div>`).join('')}</td>
                                                <td valign="top" style='min-width:100px;width:25%;' id="informationchannel">${UserMapData.äº§å“è®¤çŸ¥ä¸æ€åº¦ä¿¡æ¯æ¸ é“.map((value) => `<div>${value}</div>`).join('')}</td>
                                            </tr>
                                        </table>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
                `

                // è®¾ç½®èŠ‚ç‚¹æ ·å¼
                nodeElement.style.left = `${x}px`;
                nodeElement.style.top = `${y}px`;
                nodeElement.style.width = '1000px';  // å›ºå®šå®½åº¦
                nodeElement.style.height = 'auto'; // å›ºå®šé«˜åº¦
                nodeElement.style.overflow = 'auto';

                // æ·»åŠ "ä»…ä¾›å‚è€ƒ"æç¤ºæ–‡æœ¬
                const disclaimer = document.createElement('div');
                disclaimer.innerHTML = 'ä»…ä¾›å‚è€ƒï¼Œè‹¥ä¸å¹¸æˆä¸ºæ•™æçš„ä¸€éƒ¨åˆ†</br>è¯·å‘å­¦ç”Ÿå¼ºè°ƒéœ€è¦è‡ªè¡Œæ€è€ƒè¿‡å“ªäº›ç»“è®ºé€‚åˆï¼Œå¹¶ä¿®æ”¹ä¸é€‚åˆçš„ç»“è®º';
                disclaimer.style.fontSize = '12px';
                disclaimer.style.color = 'gray';
                disclaimer.style.textAlign = 'center';
                disclaimer.style.marginTop = '10px';
                nodeElementChild.appendChild(disclaimer);

                nodeElement.appendChild(nodeElementChild);

                canvasContainer.appendChild(nodeElement);

                const nodeData = {
                    element: nodeElement,
                    id: nodeId,
                    x: x,
                    y: y,
                    width: 1000,   // å›ºå®šå®½åº¦
                    height: 'auto',  // å›ºå®šé«˜åº¦
                    isEditing: false,
                    locked: true, // ä¿®æ”¹ï¼šPESTèŠ‚ç‚¹é»˜è®¤é”å®šä¸å¯ç¼–è¾‘
                    // PESTèŠ‚ç‚¹é»˜è®¤ä¸å¯ååº”
                    nonReactive: true
                };

                nodes.set(nodeId, nodeData);
                makeNodeInteractive(nodeData);

                return nodeData;
            }

            function create5W2HNode(x, y, data) {
                const nodeId = `node-${nodeIdCounter++}`;
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.id = nodeId;

                const nodeElementChild = document.createElement('div');

                // åˆ›å»ºè¡¨æ ¼
                const table = document.createElement('table');
                table.classList.add('Editable');
                table.contentEditable = true;
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.fontSize = '12px';

                // åˆ›å»ºè¡¨å¤´
                const headerRow = document.createElement('tr');

                const th1 = document.createElement('th');
                th1.textContent = '5W2H';
                th1.style.border = '1px solid #ddd';
                th1.style.padding = '8px';
                th1.style.backgroundColor = '#f2f2f2';
                th1.style.width = '10%';

                const th2 = document.createElement('th');
                th2.textContent = 'ç¬¬ä¸€å±‚ï¼ˆç°çŠ¶æè¿°ï¼‰';
                th2.style.border = '1px solid #ddd';
                th2.style.padding = '8px';
                th2.style.backgroundColor = '#f2f2f2';
                th2.style.width = '15%';

                const th3 = document.createElement('th');
                th3.textContent = 'ç¬¬äºŒå±‚ï¼ˆä¸ºä»€ä¹ˆï¼Ÿï¼‰';
                th3.style.border = '1px solid #ddd';
                th3.style.padding = '8px';
                th3.style.backgroundColor = '#f2f2f2';
                th3.style.width = '15%';

                const th4 = document.createElement('th');
                th4.textContent = 'ç¬¬ä¸‰å±‚ï¼ˆæœ‰æ²¡æœ‰æ›´é€‚åˆçš„ï¼Ÿï¼‰';
                th4.style.border = '1px solid #ddd';
                th4.style.padding = '8px';
                th4.style.backgroundColor = '#f2f2f2';
                th4.style.width = '15%';

                const th5 = document.createElement('th');
                th5.textContent = 'ç¬¬å››å±‚ï¼ˆä¸ºä»€ä¹ˆæ˜¯æ›´åˆé€‚çš„ï¼Ÿï¼‰';
                th5.style.border = '1px solid #ddd';
                th5.style.padding = '8px';
                th5.style.backgroundColor = '#f2f2f2';
                th5.style.width = '15%';

                const th6 = document.createElement('th');
                th6.textContent = 'ç»“è®º';
                th6.style.border = '1px solid #ddd';
                th6.style.padding = '8px';
                th6.style.backgroundColor = '#f2f2f2';
                th6.style.width = '30%';

                headerRow.appendChild(th1);
                headerRow.appendChild(th2);
                headerRow.appendChild(th3);
                headerRow.appendChild(th4);
                headerRow.appendChild(th5);
                headerRow.appendChild(th6);
                table.appendChild(headerRow);

                // å®šä¹‰5W2Hæ•°æ®é¡¹
                const w2hItems = [
                    { key: 'what', name: 'What', bgColor: '#FFD1DC', conclusionBg: '#FFD1DC' }, // ç²‰è‰²
                    { key: 'why', name: 'Why', bgColor: '#D6EAF8', conclusionBg: '#D6EAF8' }, // æµ…è“è‰²
                    { key: 'who', name: 'Who', bgColor: '#D5F5E3', conclusionBg: '#D5F5E3' }, // æµ…ç»¿è‰²
                    { key: 'when', name: 'When', bgColor: '#FADBD8', conclusionBg: '#FADBD8' }, // æµ…ç²‰è‰²
                    { key: 'where', name: 'Where', bgColor: '#EBDEF0', conclusionBg: '#EBDEF0' }, // æµ…ç´«è‰²
                    { key: 'how', name: 'How', bgColor: '#FDEBD0', conclusionBg: '#FDEBD0' }, // æµ…æ©™è‰²
                    { key: 'how_much', name: 'How much', bgColor: '#FCF3CF', conclusionBg: '#FCF3CF' } // é»„è‰²
                ];

                // ä¸ºæ¯ä¸ªW2Hé¡¹åˆ›å»ºä¸€è¡Œ
                w2hItems.forEach((item, index) => {
                    const row = document.createElement('tr');

                    // 5W2Håˆ—ï¼ˆåº”ç”¨èƒŒæ™¯é¢œè‰²ï¼‰
                    const nameCell = document.createElement('td');
                    nameCell.textContent = item.name;
                    nameCell.style.border = '1px solid #ddd';
                    nameCell.style.padding = '8px';
                    nameCell.style.backgroundColor = item.bgColor;
                    nameCell.style.fontWeight = 'bold';

                    // ç¬¬ä¸€å±‚åˆ—
                    const firstLayerCell = document.createElement('td');
                    firstLayerCell.textContent = data[item.key] ? data[item.key]["ç¬¬ä¸€å±‚"] : '';
                    firstLayerCell.style.border = '1px solid #ddd';
                    firstLayerCell.style.padding = '8px';
                    firstLayerCell.style.verticalAlign = 'top';

                    // ç¬¬äºŒå±‚åˆ—
                    const secondLayerCell = document.createElement('td');
                    secondLayerCell.textContent = data[item.key] ? data[item.key]["ç¬¬äºŒå±‚"] : '';
                    secondLayerCell.style.border = '1px solid #ddd';
                    secondLayerCell.style.padding = '8px';
                    secondLayerCell.style.verticalAlign = 'top';

                    // ç¬¬ä¸‰å±‚åˆ—
                    const thirdLayerCell = document.createElement('td');
                    thirdLayerCell.textContent = data[item.key] ? data[item.key]["ç¬¬ä¸‰å±‚"] : '';
                    thirdLayerCell.style.border = '1px solid #ddd';
                    thirdLayerCell.style.padding = '8px';
                    thirdLayerCell.style.verticalAlign = 'top';

                    // ç¬¬å››å±‚åˆ—
                    const fourthLayerCell = document.createElement('td');
                    fourthLayerCell.textContent = data[item.key] ? data[item.key]["ç¬¬å››å±‚"] : '';
                    fourthLayerCell.style.border = '1px solid #ddd';
                    fourthLayerCell.style.padding = '8px';
                    fourthLayerCell.style.verticalAlign = 'top';

                    // ç»“è®ºåˆ—ï¼ˆåº”ç”¨ç»“è®ºèƒŒæ™¯é¢œè‰²ï¼‰
                    const conclusionCell = document.createElement('td');
                    conclusionCell.textContent = data[item.key] ? data[item.key]["ç¬¬äº”å±‚"] : '';
                    conclusionCell.style.border = '1px solid #ddd';
                    conclusionCell.style.padding = '8px';
                    conclusionCell.style.backgroundColor = item.conclusionBg;
                    conclusionCell.style.fontWeight = 'bold';
                    conclusionCell.style.textAlign = 'center';

                    row.appendChild(nameCell);
                    row.appendChild(firstLayerCell);
                    row.appendChild(secondLayerCell);
                    row.appendChild(thirdLayerCell);
                    row.appendChild(fourthLayerCell);
                    row.appendChild(conclusionCell);
                    table.appendChild(row);
                });

                nodeElementChild.appendChild(table);

                nodeElementChild.appendChild(disclaimer());

                nodeElement.appendChild(nodeElementChild);

                // è®¾ç½®èŠ‚ç‚¹æ ·å¼
                nodeElement.style.left = `${x}px`;
                nodeElement.style.top = `${y}px`;
                nodeElement.style.width = '1000px';  // å¢åŠ å®½åº¦ä»¥é€‚åº”æ›´å¤šåˆ—
                nodeElement.style.height = 'auto'; // å›ºå®šé«˜åº¦
                nodeElement.style.overflow = 'auto';

                canvasContainer.appendChild(nodeElement);

                const nodeData = {
                    element: nodeElement,
                    id: nodeId,
                    x: x,
                    y: y,
                    width: 1000,   // å¢åŠ å®½åº¦
                    height: 'auto',  // å›ºå®šé«˜åº¦
                    isEditing: false,
                    locked: true, // 5W2HèŠ‚ç‚¹é»˜è®¤é”å®šä¸å¯ç¼–è¾‘
                    nonReactive: true // 5W2HèŠ‚ç‚¹é»˜è®¤ä¸å¯ååº”
                };

                nodes.set(nodeId, nodeData);
                makeNodeInteractive(nodeData);

                return nodeData;
            }

            function makeNodeInteractive(nodeData) {
                const nodeElement = nodeData.element;

                // --- åŒå‡»ç¼–è¾‘ ---
                nodeElement.addEventListener('dblclick', (e) => {
                    if (!activeDragNode) {
                        startEditing(nodeData);
                    }
                    e.stopPropagation();
                });

                nodeElement.addEventListener('mousedown', (e) => {
                    // å¦‚æœç‚¹å‡»èŠ‚ç‚¹æ—¶æœ‰å…¶ä»–èŠ‚ç‚¹æ­£åœ¨ç¼–è¾‘ï¼Œåˆ™å…ˆä¿å­˜å…¶ä»–èŠ‚ç‚¹
                    nodes.forEach(node => {
                        if (node.isEditing && node.id !== nodeData.id) {
                            const textarea = node.element.querySelector('textarea');
                            if (textarea) {
                                const newText = textarea.value.trim() || 'ç¼–è¾‘æˆ‘...';
                                node.element.classList.remove('editing');
                                node.element.textContent = newText;
                                node.isEditing = false;
                                requestAnimationFrame(() => {
                                    node.width = node.element.offsetWidth;
                                    node.height = node.element.offsetHeight;
                                });
                            }
                        }
                    });

                    if (nodeData.isEditing) return;

                    // ç¡®ä¿æ‹–æ‹½èŠ‚ç‚¹å§‹ç»ˆç½®é¡¶
                    maxZIndex++;
                    nodeElement.style.zIndex = maxZIndex;

                    activeDragNode = nodeData;
                    activeDragNode.element.classList.add('dragging');
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    e.stopPropagation();
                });

                // ç§»åŠ¨ç«¯åŒå‡»æ¨¡æ‹Ÿ (ç®€åŒ–ç‰ˆ)
                let lastTap = 0;
                nodeElement.addEventListener('touchend', (e) => {
                    if (nodeData.isEditing) return;
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    if (tapLength < 300 && tapLength > 0) {
                        // åŒå‡»äº‹ä»¶
                        startEditing(nodeData);
                        e.preventDefault();
                    }
                    lastTap = currentTime;
                    // e.stopPropagation();
                });

                // æ·»åŠ è§¦æ‘¸å¼€å§‹äº‹ä»¶ä»¥å¤„ç†ç§»åŠ¨ç«¯æ‹–æ‹½ç½®é¡¶
                nodeElement.addEventListener('touchstart', (e) => {
                    if (nodeData.isEditing) return;

                    // ç¡®ä¿æ‹–æ‹½èŠ‚ç‚¹å§‹ç»ˆç½®é¡¶
                    maxZIndex++;
                    nodeElement.style.zIndex = maxZIndex;

                    // å¯¹äºç§»åŠ¨ç«¯ï¼Œæˆ‘ä»¬ç›´æ¥åœ¨touchstartä¸­è®¾ç½®æ‹–æ‹½èµ·å§‹ç‚¹
                    activeDragNode = nodeData;
                    activeDragNode.element.classList.add('dragging');
                    dragStartX = e.touches[0].clientX;
                    dragStartY = e.touches[0].clientY;
                    e.stopPropagation();
                });
            }

            function startEditing(nodeData) {
                // --- ä¿®æ”¹ï¼šé”å®šèŠ‚ç‚¹ä¸å¯ç¼–è¾‘ ---
                if (nodeData.isEditing || nodeData.locked) return;

                nodeData.isEditing = true;
                const nodeElement = nodeData.element;
                nodeElement.classList.add('editing');

                const originalText = nodeElement.textContent;
                nodeElement.innerHTML = '';

                const textarea = document.createElement('textarea');
                textarea.value = originalText;
                // é˜»æ­¢æ‹–åŠ¨äº‹ä»¶åœ¨æ–‡æœ¬æ¡†å†…è§¦å‘
                textarea.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                });
                textarea.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                });
                nodeElement.appendChild(textarea);
                textarea.focus();

                const saveText = () => {
                    if (nodeData.isEditing) {
                        nodeData.isEditing = false;
                        nodeElement.classList.remove('editing');
                        const newText = textarea.value.trim() || 'ç¼–è¾‘æˆ‘...';
                        nodeElement.textContent = newText;
                        requestAnimationFrame(() => {
                            nodeData.width = nodeElement.offsetWidth;
                            nodeData.height = nodeElement.offsetHeight;
                        });
                    }
                };

                textarea.addEventListener('blur', saveText);
                textarea.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        saveText();
                    }
                });

                // è¿”å›saveTextå‡½æ•°ï¼Œä»¥ä¾¿å¤–éƒ¨å¯ä»¥è°ƒç”¨
                return saveText;
            }

            // --- Overlap and API Logic ---
            let isApiCallInProgress = false;

            // æ–°å¢å‡½æ•°ï¼šåœ¨æ‹–åŠ¨è¿‡ç¨‹ä¸­æ£€æŸ¥é‡å ï¼Œä½†ä¸è§¦å‘API
            function checkOverlapDuringDrag(draggedNode) {
                let isOverlapping = false;
                let overlappingNode = null;

                for (const [id, otherNode] of nodes) {
                    if (id !== draggedNode.id) {
                        const overlapArea = getOverlapArea(draggedNode, otherNode);
                        if (overlapArea > 0) {
                            const area1 = getArea(draggedNode);
                            const area2 = getArea(otherNode);
                            const minArea = Math.min(area1, area2);

                            // --- æ£€æŸ¥ 90% é‡å  ---
                            if (overlapArea / minArea > 0.9) {
                                // æ–°å¢ï¼šæ£€æŸ¥ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦éƒ½å¯ååº”
                                if (!draggedNode.nonReactive && !otherNode.nonReactive) {
                                    isOverlapping = true;
                                    overlappingNode = otherNode;
                                    draggedNode.element.classList.add('overlapping');
                                    otherNode.element.classList.add('overlapping');
                                    // --- è®°å½•å¾…è§¦å‘çš„APIè°ƒç”¨ä¿¡æ¯ ---
                                    pendingApiCall = { nodeA: draggedNode, nodeB: overlappingNode };
                                    break; // æ‰¾åˆ°ä¸€ä¸ªå³å¯
                                }
                            } else {
                                // ç§»é™¤æœªè¾¾åˆ°é˜ˆå€¼çš„é‡å æ ·å¼
                                draggedNode.element.classList.remove('overlapping');
                                otherNode.element.classList.remove('overlapping');
                            }
                        } else {
                            // æ²¡æœ‰é‡å æ—¶ç§»é™¤æ ·å¼
                            draggedNode.element.classList.remove('overlapping');
                            otherNode.element.classList.remove('overlapping');
                        }
                    }
                }

                // å¦‚æœæ²¡æœ‰é‡å ï¼Œåˆ™æ¸…é™¤å¾…è§¦å‘ä¿¡æ¯
                if (!isOverlapping) {
                    pendingApiCall = null;
                    // ç¡®ä¿æ‰€æœ‰èŠ‚ç‚¹çš„é‡å æ ·å¼éƒ½è¢«æ¸…é™¤
                    nodes.forEach(node => {
                        if (node.id !== draggedNode.id) {
                            node.element.classList.remove('overlapping');
                        }
                    });
                }
            }

            async function callApiAndCreateNodes(nodeA, nodeB) {
                if (isApiCallInProgress) return; // é˜²æ­¢é‡å¤è°ƒç”¨

                isApiCallInProgress = true;
                apiIndicator.style.display = 'block';
                const nodeAText = nodeA.element.textContent
                const nodeBText = nodeB.element.textContent
                // console.log(nodeAText, nodeBText)


                // æ–°å¢ï¼šæ£€æŸ¥æ˜¯å¦æœ‰ç‰¹å®šå†…å®¹çš„é”å®šèŠ‚ç‚¹å­˜åœ¨
                function checkLockedNodeWithContent(content) {
                    for (const [id, node] of nodes) {
                        if (node.locked && node.element.textContent === content) {
                            return true;
                        }
                    }
                    return false;
                }

                // æ–°å¢ï¼šæ‰§è¡Œæ–°å‡½æ•°çš„é€»è¾‘
                function executeNewFunction(content) {
                    if (content == 'è”æƒ³å…³é”®è¯' || content == 'å·¥ä¸šè®¾è®¡åˆ†æç»´åº¦') {
                        unlockNode('STPæˆ˜ç•¥ã€ç«å“åˆ†æ')
                        addLockedNode('STPæˆ˜ç•¥')
                        addLockedNode('ç«å“åˆ†æ')
                        // addLockedNode('ç›´æ¥å›ç­”èŠ‚ç‚¹')
                    }
                    if (content == 'STPæˆ˜ç•¥') {
                        unlockNode('SWOTã€PEST')
                        addLockedNode('SWOT')
                        addLockedNode('PEST')
                        addLockedNode('5W2H')
                    }
                    // if (content == 'SWOT' || content == 'PEST') {
                    //     unlockNode('ç«å“åˆ†æ')
                    //     addLockedNode('ç«å“åˆ†æ')
                    // }
                    if (content == 'ç«å“åˆ†æ') {
                        unlockNode('æ–°å…´æŠ€æœ¯ã€ç”¨æˆ·ç”»åƒã€CMF')
                        addLockedNode('æ–°å…´æŠ€æœ¯')
                        addLockedNode('ç”¨æˆ·ç”»åƒ')
                        addLockedNode('CMF')
                    }
                    // if (content == 'ç”¨æˆ·ç”»åƒ') {
                    //     unlockNode('CMF')
                    //     addLockedNode('CMF')
                    // }
                }

                // æ–°å¢ï¼šæ£€æŸ¥ä¸¤ä¸ªå‚ä¸ååº”çš„èŠ‚ç‚¹å†…å®¹ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰å¯¹åº”çš„é”å®šèŠ‚ç‚¹
                if (checkLockedNodeWithContent(nodeAText)) {
                    executeNewFunction(nodeAText);
                }

                if (checkLockedNodeWithContent(nodeBText)) {
                    executeNewFunction(nodeBText);
                }

                try {
                    // ä¿®å¤ï¼šæ­£ç¡®ç­‰å¾…APIå“åº”
                    const simulatedApiResponse = await getApiResponse([nodeAText, nodeBText]);

                    // console.log(simulatedApiResponse, getType(simulatedApiResponse) === 'object')
                    // æ£€æŸ¥è¿”å›çš„æ•°æ®ç±»å‹ï¼Œå¦‚æœæ˜¯å¯¹è±¡ï¼ˆå­—å…¸ï¼‰åˆ™æŒ‰SWOTè¡¨æ ¼å¤„ç†
                    if (getType(simulatedApiResponse) === 'object') {
                        // åˆ›å»ºSWOTåˆ†æè¡¨æ ¼èŠ‚ç‚¹
                        const centerX = (nodeA.x + nodeA.width / 2 + nodeB.x + nodeB.width / 2) / 2;
                        const centerY = (nodeA.y + nodeA.height / 2 + nodeB.y + nodeB.height / 2) / 2;
                        if ([nodeAText, nodeBText].includes('SWOT')) {
                            // åˆ›å»ºåŒ…å«SWOTè¡¨æ ¼çš„èŠ‚ç‚¹
                            createSWOTNode(centerX - 150, centerY - 100, simulatedApiResponse);
                        }
                        else if ([nodeAText, nodeBText].includes('PEST')) {
                            createPESTNode(centerX - 150, centerY - 100, simulatedApiResponse);
                        }
                        else if ([nodeAText, nodeBText].includes('STPæˆ˜ç•¥')) {
                            createSTPNode(centerX - 150, centerY - 100, simulatedApiResponse);
                        }
                        else if ([nodeAText, nodeBText].includes('CMF')) {
                            createCMFNode(centerX - 150, centerY - 100, simulatedApiResponse);
                        }
                        else if ([nodeAText, nodeBText].includes('ç”¨æˆ·ç”»åƒ')) {
                            createUserMapNode(centerX - 150, centerY - 100, simulatedApiResponse);
                        }
                        else if ([nodeAText, nodeBText].includes('ç«å“åˆ†æ')) {
                            createCompetitiveAnalysisNode(centerX - 150, centerY - 100, simulatedApiResponse);
                        }
                        else if ([nodeAText, nodeBText].includes('5W2H')) {
                            console.log('5W2H')
                            console.log(simulatedApiResponse)
                            create5W2HNode(centerX - 150, centerY - 100, simulatedApiResponse);
                        }
                        // return;
                    } else {
                        // æ–°å¢ï¼šå¸¸è§„åˆ—è¡¨å»é‡
                        const existingNodeTexts = Array.from(nodes.values()).map(node => node.element.textContent);
                        const uniqueNewNodes = simulatedApiResponse.filter(text => !existingNodeTexts.includes(text));

                        // å¦‚æœæ‰€æœ‰æ–°èŠ‚ç‚¹éƒ½é‡å¤ï¼Œåˆ™æ˜¾ç¤ºæç¤ºä¿¡æ¯
                        if (uniqueNewNodes.length === 0) {
                            // åˆ›å»ºæç¤ºå…ƒç´ 
                            const noIdeaIndicator = document.createElement('div');
                            noIdeaIndicator.textContent = 'å—ç¥æ²¡æ€è·¯äº†ï¼Œè¯·ä½ è‡ªè¡Œæ€è€ƒï¼ŒåŠ æ²¹';
                            noIdeaIndicator.style.position = 'fixed';
                            noIdeaIndicator.style.top = '70px';
                            noIdeaIndicator.style.right = '20px';
                            noIdeaIndicator.style.padding = '10px 15px';
                            noIdeaIndicator.style.backgroundColor = '#fffbe6';
                            noIdeaIndicator.style.border = '1px solid #ffe58f';
                            noIdeaIndicator.style.borderRadius = '8px';
                            noIdeaIndicator.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
                            noIdeaIndicator.style.fontSize = '14px';
                            noIdeaIndicator.style.color = '#d48806';
                            noIdeaIndicator.style.zIndex = '1002';
                            noIdeaIndicator.id = 'no-idea-indicator';

                            document.body.appendChild(noIdeaIndicator);


                            // 3ç§’åè‡ªåŠ¨éšè—æç¤º
                            setTimeout(() => {
                                if (noIdeaIndicator.parentNode) {
                                    noIdeaIndicator.parentNode.removeChild(noIdeaIndicator);
                                }
                            }, 3000);

                            return; // ç›´æ¥è¿”å›ï¼Œä¸åˆ›å»ºæ–°èŠ‚ç‚¹
                        }

                        const newNodes = [];
                        // è®¡ç®—ä¸¤ä¸ªé‡å èŠ‚ç‚¹çš„ä¸­å¿ƒç‚¹ (ä¸–ç•Œåæ ‡)
                        const centerX = (nodeA.x + nodeA.width / 2 + nodeB.x + nodeB.width / 2) / 2;
                        const centerY = (nodeA.y + nodeA.height / 2 + nodeB.y + nodeB.height / 2) / 2;

                        const radius = 150;

                        // é€ä¸ªåˆ›å»ºèŠ‚ç‚¹å¹¶æ£€æŸ¥é‡å  (ä¿®æ”¹å¤„ç†é€»è¾‘ä»¥é€‚åº”æ–°çš„æ•°æ®æ ¼å¼)
                        // ä½¿ç”¨è¿‡æ»¤åçš„å†…å®¹åˆ›å»ºèŠ‚ç‚¹
                        uniqueNewNodes.forEach((text, index) => {
                            const angle = (index / uniqueNewNodes.length) * 2 * Math.PI;

                            // å…ˆåˆ›å»ºèŠ‚ç‚¹ä»¥è·å–å®é™…å°ºå¯¸
                            let proposedX = centerX + radius * Math.cos(angle) - 65;
                            let proposedY = centerY + radius * Math.sin(angle) - 35;

                            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶æ•°ç»„ï¼ŒåŒ…å«æ‰€æœ‰ç°æœ‰èŠ‚ç‚¹å’Œå·²ç»åˆ›å»ºçš„æ–°èŠ‚ç‚¹
                            const allNodes = Array.from(nodes.values()).concat(newNodes);

                            // å…ˆåˆ›å»ºèŠ‚ç‚¹ä»¥è·å–å®é™…å°ºå¯¸
                            const tempNode = createNode(proposedX, proposedY, text);
                            newNodes.push(tempNode);

                            // ç„¶åæ£€æŸ¥é‡å å¹¶è°ƒæ•´ä½ç½®
                            let hasOverlap = false;
                            let attempts = 0;
                            const maxAttempts = 100;

                            do {
                                hasOverlap = false;

                                // æ£€æŸ¥ä¸æ‰€æœ‰ç°æœ‰èŠ‚ç‚¹çš„é‡å æƒ…å†µ
                                for (const existingNode of allNodes) {
                                    if (getOverlapArea(tempNode, existingNode) > 0) {
                                        hasOverlap = true;
                                        break;
                                    }
                                }

                                if (hasOverlap) {
                                    // è°ƒæ•´ä½ç½®
                                    const newAngle = (index / uniqueNewNodes.length) * 2 * Math.PI + (attempts * 0.5);
                                    const newRadius = radius + attempts * 20;
                                    tempNode.x = centerX + newRadius * Math.cos(newAngle) - tempNode.width / 2;
                                    tempNode.y = centerY + newRadius * Math.sin(newAngle) - tempNode.height / 2;

                                    // æ›´æ–°èŠ‚ç‚¹ä½ç½®
                                    tempNode.element.style.left = `${tempNode.x}px`;
                                    tempNode.element.style.top = `${tempNode.y}px`;

                                    attempts++;
                                }
                            } while (hasOverlap && attempts < maxAttempts);
                        });
                        // --- ä»…ä»¥æ–°ç”Ÿæˆçš„èŠ‚ç‚¹ä¸ºä¸­å¿ƒè¿›è¡Œç§»åŠ¨ ---
                        centerViewOnNodes(newNodes);
                    }
                } catch (error) {
                    console.error('APIè°ƒç”¨å¤±è´¥:', error);
                    apiIndicatorFailed.style.display = 'block';
                    setTimeout(() => {
                        apiIndicatorFailed.style.display = 'none';
                    }, 3000);
                } finally {
                    apiIndicator.style.display = 'none';
                    isApiCallInProgress = false;
                }
            }

            // --- Initial Setup ---
            createNode(200, 150, 'åŒå‡»ç¼–è¾‘å†…å®¹');
            createNode(200, 200, 'å·¥ä¸šè®¾è®¡åˆ†æç»´åº¦', 1);
            createNode(300, 200, 'è”æƒ³å…³é”®è¯', 1);
            // addLockedNode(LockNodeName)æ·»åŠ é”å®šèŠ‚ç‚¹
            // ç”¨æˆ·ç¾¤ä½“ï¼Œå¸‚åœºèƒŒæ™¯ï¼Œæˆæœ¬ï¼Œæ„ä¹‰ï¼Œå‰æ²¿è®¾è®¡ç†å¿µï¼Œäº§å“é™„åŠ å€¼
            // SWOTï¼ŒPEST
            // è‰²å½©ã€ææ–™ã€è¡¨é¢å¤„ç†
            // AI+ã€T

            // --- Add Wheel Listener for Zoom ---
            body.addEventListener('wheel', handleWheel, { passive: false });

            // --- æ·»åŠ æŠ–åŠ¨åŠ¨ç”»æ ·å¼ ---
            const style = document.createElement('style');
            style.textContent = `
                @keyframes shake {
                    0%, 100% { transform: translateX(0); }
                    25% { transform: translateX(-5px); }
                    75% { transform: translateX(5px); }
                }
            `;
            document.head.appendChild(style);

            // --- åˆå§‹éšè—æ“ä½œè¯´æ˜ ---
            const instructions = document.querySelector('.instructions');
            const instructionsHeader = instructions.querySelector('h3');

            // æ·»åŠ æŠ˜å /å±•å¼€åŠŸèƒ½
            instructionsHeader.style.cursor = 'pointer';
            instructionsHeader.addEventListener('click', () => {
                const content = instructions.querySelector('ul');
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    instructionsHeader.textContent = 'æ“ä½œè¯´æ˜ â–¼';
                } else {
                    content.style.display = 'none';
                    instructionsHeader.textContent = 'æ“ä½œè¯´æ˜ â–²';
                }
            });

            // åˆå§‹åŒ–ä¸ºå±•å¼€çŠ¶æ€
            // instructionsHeader.textContent = 'æ“ä½œè¯´æ˜ â–¼';
            // åˆå§‹åŒ–ä¸ºæŠ˜å çŠ¶æ€
            instructionsHeader.textContent = 'æ“ä½œè¯´æ˜ â–²';
            instructions.querySelector('ul').style.display = 'none';
        });

        function getType(value) {
            if (value === null) {
                return 'null';
            } else if (Array.isArray(value)) {
                return 'array';
            } else if (typeof value === 'object') {
                return 'object';
            } else {
                return typeof value;
            }
        }

        // ä¿®å¤ï¼šä½¿å‡½æ•°è¿”å›Promiseä»¥æ­£ç¡®å¤„ç†å¼‚æ­¥æ“ä½œ
        function getApiResponse(message) {
            return new Promise((resolve, reject) => {
                function defaultMessageKeyWord(message) {
                    return `æˆ‘æ˜¯å·¥ä¸šè®¾è®¡å¸ˆï¼Œè¯·åŸºäºå…³é”®è¯ [${message}]ï¼Œ
ä¸ºæˆ‘æ¨è 5 åˆ° 10 ä¸ªæœ€ç›¸å…³ã€æœ€å…·è°ƒç ”ä»·å€¼ä¸è®¾è®¡å¯å‘æ€§çš„æ‰©å±•å…³é”®è¯æˆ–çŸ­è¯­ï¼Œï¼ˆæœ€å¤šä¸è¶…è¿‡ 10 ä¸ªï¼‰
0ã€å½“å…³é”®è¯ã€${message[0]}ä¸${message[1]}ã€‘ä¸­å­˜åœ¨ã€åˆ†æã€åˆ¤æ–­ã€ç ”ç©¶ã€è®¾è®¡ã€ä¼˜åŒ–ã€è¯„ä»·ã€åº”ç”¨ã€‘ç­‰å…³é”®è¯æ—¶ï¼Œç›´æ¥å¯¹å›ç­”è¯¥é—®é¢˜çš„ç­”æ¡ˆã€‚
2ã€å½“ä¸¤ä¸ªå…³é”®è¯ã€${message[0]}ä¸${message[1]}ã€‘å­˜åœ¨è½¬æŠ˜å…³ç³»ã€å‡è®¾å…³ç³»ã€å¹¶åˆ—å…³ç³»ã€é€’è¿›å…³ç³»ã€é€‰æ‹©å…³ç³»ã€å› æœå…³ç³»ã€æ¡ä»¶å…³ç³»ã€æ‰¿æ¥å…³ç³»æ—¶ï¼Œç›´æ¥è¾“å‡ºç»“æœç­”æ¡ˆã€‚
3ã€é«˜å¯å‘æ€§ï¼šèƒ½æ¿€å‘è®¾è®¡æ€è€ƒã€æ‰“å¼€åˆ›æ–°ç»´åº¦ï¼Œé¿å…é™ˆè¯æ»¥è°ƒæˆ–æ³›æ³›ä¹‹è¯ã€‚
è¦æ±‚ï¼šè¯·ç›´æ¥ä»¥ JSON æ ¼å¼è¾“å‡ºä¸€ä¸ªåˆ—è¡¨ï¼Œç¦æ­¢å‡ºç°åˆ—è¡¨åµŒå¥—ï¼Œæ ¼å¼ä¸ºï¼š
\`\`\`json
[]
\`\`\``.replace(/\n/g, '')


                    //                     `
                    // æˆ‘æ˜¯ä¸€åå·¥ä¸šè®¾è®¡å¸ˆï¼Œç›®å‰æ­£åœ¨ä¸ºå“ç±»è¿›è¡Œå‰æœŸè°ƒç ”ä¸è®¾è®¡æ–¹å‘æ¢ç´¢ã€‚

                    // è¯·åŸºäºå…³é”®è¯ [${message}]ï¼Œä¸ºæˆ‘æ¨è 3 åˆ° 7 ä¸ªæœ€ç›¸å…³ã€æœ€å…·è°ƒç ”ä»·å€¼ä¸è®¾è®¡å¯å‘æ€§çš„æ‰©å±•å…³é”®è¯æˆ–çŸ­è¯­ï¼ˆæœ€å¤šä¸è¶…è¿‡ 10 ä¸ªï¼‰ã€‚è¦æ±‚ï¼š

                    // å¼ºä¸“ä¸šç›¸å…³ï¼šæ¯ä¸ªè¯å¿…é¡»ç´§å¯†å›´ç»•â€œ${message}â€ä¸¤ä¸ªæˆ–å¤šä¸ªå…³é”®è¯ï¼Œèƒ½ç›´æ¥ç”¨äºç”¨æˆ·ç ”ç©¶ã€è¶‹åŠ¿åˆ†æã€CMFæ¢ç´¢ã€ç»“æ„åˆ›æ–°æˆ–è®¾è®¡å®šä½ã€‚ä¸”èƒ½ç›´æ¥åº”ç”¨äºå·¥ä¸šè®¾è®¡å…¨æµç¨‹å…³é”®ç¯èŠ‚â€”â€”ç”¨æˆ·ç ”ç©¶ç¯èŠ‚éœ€å…³è”ç‰¹å®šäººç¾¤çš„å…·ä½“è¡Œä¸ºåå¥½ä¸ç”Ÿç†/å¿ƒç†éœ€æ±‚ï¼Œç«å“åˆ†æç¯èŠ‚éœ€æŒ‡å‘å‚ç›´é¢†åŸŸå†…äº§å“çš„åŠŸèƒ½å·®å¼‚ä¸æŠ€æœ¯å‚æ•°å¯¹æ¯”ï¼ŒCMFæ¢ç´¢ç¯èŠ‚éœ€å¯¹åº”ç‰¹å®šåœºæ™¯ä¸‹çš„æè´¨ç‰¹æ€§é€‰å‹ã€è‰²å½©æƒ…æ„Ÿé€‚é…ä¸è¡¨é¢å¤„ç†å·¥è‰ºéœ€æ±‚ï¼Œç»“æ„åˆ›æ–°ç¯èŠ‚éœ€å¥‘åˆç‰¹å®šä½¿ç”¨äººç¾¤çš„äººä½“å·¥å­¦é€‚é…ã€ä½¿ç”¨åœºæ™¯çš„ç¯å¢ƒé€‚åº”æ€§ä¸æ ¸å¿ƒåŠŸèƒ½çš„ç¨³å®šæ€§ä¼˜åŒ–ï¼Œè®¾è®¡å®šä½ç¯èŠ‚éœ€æ˜ç¡®ç»†åˆ†äººç¾¤çš„å·®å¼‚åŒ–éœ€æ±‚æ»¡è¶³ä¸ç»†åˆ†å¸‚åœºçš„ç‹¬ç‰¹ä»·å€¼ä¸»å¼ ï¼›
                    // è°ƒç ”å¯¼å‘ï¼šè¯æ±‡åº”å…·å¤‡è°ƒç ”å…³é”®è¯å±æ€§ï¼Œå¯ç”¨äºæœç´¢æ–‡çŒ®ã€ç«å“åˆ†æã€è®¾è®¡æ¡ˆä¾‹ã€ç”¨æˆ·ç—›ç‚¹æˆ–æŠ€æœ¯è¶‹åŠ¿ã€‚
                    // é«˜å¯å‘æ€§ï¼šèƒ½æ¿€å‘è®¾è®¡æ€è€ƒã€æ‰“å¼€åˆ›æ–°ç»´åº¦ï¼Œé¿å…é™ˆè¯æ»¥è°ƒæˆ–æ³›æ³›ä¹‹è¯ã€‚éœ€èšç„¦å¤šç»´åº¦ç»†åˆ†æ–¹å‘â€”â€”äººç¾¤ç»´åº¦éœ€è¦†ç›–ä¸åŒå¹´é¾„å±‚ã€èŒä¸šç±»å‹ã€ç”Ÿç†ç‰¹å¾ã€è¡Œä¸ºä¹ æƒ¯çš„ç²¾å‡†ç•Œå®šï¼Œåœºæ™¯ç»´åº¦éœ€åŒ…å«å…·ä½“ä½¿ç”¨ç¯å¢ƒã€ä½¿ç”¨ç›®çš„ã€ä½¿ç”¨æ—¶æ®µã€ä½¿ç”¨å·¥å†µçš„æ˜ç¡®åˆ’åˆ†ï¼ŒåŠŸèƒ½ç»´åº¦éœ€æ¶‰åŠæ ¸å¿ƒåŠŸèƒ½å»¶ä¼¸ã€ç‰¹æ®Šéœ€æ±‚æ»¡è¶³ã€ä½¿ç”¨ä½“éªŒä¼˜åŒ–çš„æ·±åº¦æŒ–æ˜ï¼Œä¸”æ¯ä¸ªæ‰©å±•è¯éœ€èƒ½å¤Ÿå¼•å¯¼è®¾è®¡äººå‘˜ä»æè´¨ã€ç»“æ„ã€äº¤äº’ã€å½¢æ€ã€åŠŸèƒ½ç­‰å¤šç»´åº¦äº§ç”Ÿåˆ›æ–°æ€§æ€è€ƒï¼Œæ¨åŠ¨è®¾è®¡æ–¹æ¡ˆå‘å·®å¼‚åŒ–ã€ç²¾ç»†åŒ–æ–¹å‘å‘å±•ï¼›
                    // ç²¾å‡†å…‹åˆ¶ï¼šå®å¯å°‘ï¼Œä¸å¯æ»¥ã€‚æ‹’ç»ä¸åŸå§‹è¯é‡å¤æˆ–å½¼æ­¤è¯­ä¹‰é‡å ã€‚ä¸åˆ†ç±»ã€ä¸åˆ†ç»„ï¼Œåªè¾“å‡ºæœ€ç²¾åçš„3-7ä¸ªè¯ã€‚
                    // æœ€é‡è¦çš„æ˜¯ï¼šåˆ†æä¸¤ä¸ªå…³é”®è¯å¹¶æ­ç¤ºå‡ºæ½œåœ¨çš„è®¾è®¡æ–¹å‘ã€‚
                    // è¯·ç›´æ¥ä»¥ JSON æ ¼å¼è¾“å‡ºä¸€ä¸ªåˆ—è¡¨ï¼Œç¦æ­¢å‡ºç°åˆ—è¡¨åµŒå¥—ï¼Œæ ¼å¼ä¸ºï¼š
                    // \`\`\`json
                    // []
                    // \`\`\`
                    //                 `.replace(/\n/g, '')
                }
                function defaultMessagePEST(message) {
                    return `è¯·ä¸ºä»¥ä¸‹å…³é”®è¯ç”Ÿæˆä¸€ä¸ªè¯¦ç»†çš„â€œåŸºäºå¸‚åœºç¯å¢ƒåˆ†æçš„PESTELâ€åˆ†æï¼š[${message}]ã€‚åˆ†æåº”åˆ†ä¸ºå››ä¸ªéƒ¨åˆ†ï¼š
Political (æ”¿æ²»)ï¼šåˆ—å‡º2-5ä¸ªå…³é”®ç‚¹ï¼ŒåŸºäºå¸‚åœºç¯å¢ƒåˆ†æè¡Œä¸šæ”¿ç­–è¶‹åŠ¿ã€‚ç”¨ç®€æ´ä½†åŒ…å«æ•°æ®æ”¯æ’‘çš„æè¿°æ€§çŸ­è¯­è¡¨è¿°ï¼Œé¿å…æŠ½è±¡æœ¯è¯­ï¼Œç¡®ä¿å†…å®¹å¯éªŒè¯ä¸”é€»è¾‘è¿è´¯ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°ã€‚
Economic (ç»æµ)ï¼šåˆ—å‡º2-5ä¸ªå…³é”®ç‚¹ï¼ŒåŸºäºå¸‚åœºç¯å¢ƒåˆ†æå®è§‚ç»æµæ•°æ®ã€‚ç”¨ç®€æ˜ä½†åŒ…å«é‡åŒ–ç»†èŠ‚çš„æè¿°æ€§çŸ­è¯­è¡¨è¿°ï¼Œç¡®ä¿å†…å®¹åŸºäºæœ€æ–°æƒå¨æ•°æ®ä¸”å®ç”¨ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°ã€‚
Social (ç¤¾ä¼š)ï¼šåˆ—å‡º2-5ä¸ªå…³é”®ç‚¹ï¼ŒåŸºäºå¸‚åœºç¯å¢ƒåˆ†ææ¶ˆè´¹è¡Œä¸ºå˜åŒ–ã€‚ç”¨æè¿°æ€§çŸ­è¯­æ¸…æ™°å‘ˆç°è¡Œä¸ºä¸å•†ä¸šå½±å“çš„å…³è”ï¼Œé¿å…æ³›æ³›è€Œè°ˆï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°ã€‚
Technological (æŠ€æœ¯)ï¼šåˆ—å‡º2-5ä¸ªå…³é”®ç‚¹ï¼ŒåŸºäºå¸‚åœºç¯å¢ƒåˆ†ææŠ€æœ¯åº”ç”¨è¿›å±•ã€‚ç”¨æŠ€æœ¯ç»†èŠ‚ä¸å®è¯æ•ˆæœç»“åˆçš„æè¿°æ€§çŸ­è¯­è¡¨è¿°ï¼Œç¡®ä¿å†…å®¹å‰æ²¿ä¸”å¯æ“ä½œï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°ã€‚
æ¯ä¸ªç‚¹éœ€åŸºäºè¡Œä¸šå¸¸è¯†ï¼Œé¿å…æ¨¡ç³Šæè¿°ï¼Œç¡®ä¿å†…å®¹å…·ä½“ã€å®ç”¨ä¸”é€»è¾‘è¿è´¯ã€‚

è¯·ç›´æ¥ä»¥ JSON æ ¼å¼è¾“å‡ºä¸€ä¸ªåˆ—è¡¨ï¼Œç¦æ­¢å‡ºç°åˆ—è¡¨åµŒå¥—ï¼Œæ ¼å¼ä¸ºï¼š
\`\`\`json
{
    "Political": [],
    "Economic": [],
    "Social": [],
    "Technological": [],
}
\`\`\``.replace(/\n/g, '')
                }
                function defaultMessageSWOT(message) {
                    return `è¯·ä¸ºä»¥ä¸‹å…³é”®è¯ç”Ÿæˆä¸€ä¸ªè¯¦ç»†çš„åŸºäºäº§å“å“ç±»çš„SWOTåˆ†æï¼š[${message}]ã€‚åˆ†æåº”åˆ†ä¸ºå››ä¸ªéƒ¨åˆ†ï¼š

Strengthsï¼ˆä¼˜åŠ¿ï¼‰ï¼šåˆ—å‡º2-5ä¸ªå…³é”®ä¼˜åŠ¿ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°
Weaknessesï¼ˆåŠ£åŠ¿ï¼‰ï¼šåˆ—å‡º2-5ä¸ªå…³é”®åŠ£åŠ¿ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°
Opportunitiesï¼ˆæœºä¼šï¼‰ï¼šåˆ—å‡º2-5ä¸ªå…³é”®æœºä¼šï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°
Threatsï¼ˆå¨èƒï¼‰ï¼šåˆ—å‡º2-5ä¸ªå…³é”®å¨èƒï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°
æ¯ä¸ªç‚¹éœ€åŸºäºè¡Œä¸šå¸¸è¯†ï¼Œç®€æ˜æ‰¼è¦ï¼Œé¿å…æ¨¡ç³Šæè¿°ï¼Œç¡®ä¿å†…å®¹å…·ä½“ã€å®ç”¨ä¸”é€»è¾‘è¿è´¯ã€‚

è¯·ç›´æ¥ä»¥ JSON æ ¼å¼è¾“å‡ºä¸€ä¸ªåˆ—è¡¨ï¼Œç¦æ­¢å‡ºç°åˆ—è¡¨åµŒå¥—ï¼Œæ ¼å¼ä¸ºï¼š
\`\`\`json
{
    "strengths": [],
    "weaknesses": [],
    "opportunities": [],
    "threats": []
}
\`\`\``.replace(/\n/g, '')
                }
                function defaultMessageSTP(message) {
                    return `è¯·ä¸ºä»¥ä¸‹å…³é”®è¯ç”Ÿæˆä¸€ä¸ªè¯¦å°½çš„STPåˆ†æï¼š[${message}]ã€‚åˆ†æåº”åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ï¼Œæ¯éƒ¨åˆ†éœ€åŸºäºè¡Œä¸šå¸¸è¯†å’Œå¸‚åœºé€»è¾‘ï¼Œå†…å®¹å…·ä½“ã€ç»“æ„æ¸…æ™°ã€å¯ç›´æ¥ç”¨äºè¥é”€æˆ˜ç•¥åˆ¶å®šï¼š

Segmentationï¼ˆå¸‚åœºç»†åˆ†ï¼‰ï¼š
åˆ—å‡º2-5ä¸ªç›®æ ‡å®¢æˆ·ç»†åˆ†ç¾¤ä½“ã€‚æ¯ä¸ªç¾¤ä½“éœ€æ˜ç¡®æè¿°å…¶äººå£ç‰¹å¾ã€åœ°ç†åˆ†å¸ƒã€å¿ƒç†ç‰¹å¾åŠè¡Œä¸ºç‰¹å¾ã€‚é¿å…ç¬¼ç»Ÿåˆ†ç±»ï¼Œç¡®ä¿ç»†åˆ†ç»´åº¦å…·æœ‰å•†ä¸šå¯æ“ä½œæ€§ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°ã€‚
Targetingï¼ˆç›®æ ‡å¸‚åœºé€‰æ‹©ï¼‰ï¼š
ä»ä¸Šè¿°ç»†åˆ†ä¸­é€‰æ‹©1-3ä¸ªæœ€å…·æ½œåŠ›çš„ç›®æ ‡å¸‚åœºã€‚å¯¹æ¯ä¸ªé€‰å®šå¸‚åœºè¯´æ˜é€‰æ‹©ç†ç”±ï¼ŒåŒ…æ‹¬ç›®æ ‡å¸‚åœºã€å¸‚åœºè§„æ¨¡ã€å¢é•¿æ½œåŠ›ã€ç«äº‰å¼ºåº¦ã€‚éœ€ä½“ç°æˆ˜ç•¥å–èˆï¼Œé¿å…â€˜å…¨è¦†ç›–â€™å¼æè¿°ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°ã€‚
Positioningï¼ˆå¸‚åœºå®šä½ï¼‰ï¼š
ä¸ºé€‰å®šçš„ç›®æ ‡å¸‚åœºæ˜ç¡®å“ç‰Œæˆ–äº§å“çš„æ ¸å¿ƒå®šä½ã€‚æ¯æ¡å®šä½éœ€åŒ…å«ä»·å€¼ä¸»å¼ ã€å·®å¼‚åŒ–æ”¯æ’‘ç‚¹åŠç«äº‰å‚ç…§ç³»ã€‚è¡¨è¾¾åº”ç®€æ´æœ‰åŠ›ï¼Œé€‚åˆè½¬åŒ–ä¸ºå¯¹å¤–ä¼ æ’­å£å·ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°ã€‚

è¯·ç›´æ¥ä»¥ JSON æ ¼å¼è¾“å‡ºï¼Œç¦æ­¢åµŒå¥—åˆ—è¡¨ï¼Œæ ¼å¼ä¸ºï¼š
\`\`\`json
{
  "segmentation": [
  {'äººå£ç‰¹å¾':'','åœ°ç†åˆ†å¸ƒ':'','å¿ƒç†ç‰¹å¾':'','è¡Œä¸ºç‰¹å¾':''}
  ],
  "targeting": [
    {'ç›®æ ‡å¸‚åœº':'','å¸‚åœºè§„æ¨¡':'','å¢é•¿æ½œåŠ›':'','ç«äº‰å¼ºåº¦':''}
  ],
  "positioning": [
    {'å¸‚åœºå®šä½':'','ä»·å€¼ä¸»å¼ ':'','å·®å¼‚åŒ–æ”¯æ’‘ç‚¹':'','ç«äº‰å‚ç…§ç³»':''}
  ]
}\`\`\``.replace(/\n/g, '')
                }
                function defaultMessageCMF(message) {
                    return `è¯·ä¸ºä»¥ä¸‹å…³é”®è¯ç”Ÿæˆä¸€ä¸ªä¸“ä¸šçš„CMFåˆ†æï¼š[${message}]ã€‚
åˆ†æåº”å›´ç»•è‰²å½©ï¼ˆColorï¼‰ã€ææ–™ï¼ˆMaterialï¼‰ã€è¡¨é¢å¤„ç†ï¼ˆFinishingï¼‰ä¸‰ä¸ªç»´åº¦ï¼Œé’ˆå¯¹äº§å“è®¾è®¡æˆ–å“ç‰Œå½¢è±¡è¿›è¡Œç³»ç»Ÿæ€§é˜è¿°ï¼Œå†…å®¹éœ€å…·å¤‡è¡Œä¸šå‰ç»æ€§ã€ç¾å­¦åˆ¤æ–­åŠ›ä¸å·¥ç¨‹å¯è¡Œæ€§ï¼Œé€‚ç”¨äºæ¶ˆè´¹å“ã€ç”µå­äº§å“ã€å®¶å±…æˆ–äº¤é€šå·¥å…·ç­‰é¢†åŸŸã€‚

è¾“å‡ºè¦æ±‚ï¼š
- æ¯ä¸ªç»´åº¦ï¼ˆColorã€Materialã€Finishingï¼‰åˆ†åˆ«åˆ—å‡º2-4é¡¹å…·ä½“å»ºè®®ã€‚
- æ¯é¡¹å»ºè®®éœ€åŒ…å«ï¼š
  a) å…·ä½“æ–¹æ¡ˆï¼ˆå¦‚è‰²å½©åç§°/æ½˜é€šè‰²å·ã€ææ–™ç±»å‹ã€å·¥è‰ºåç§°ï¼‰ï¼›
  b) è®¾è®¡æ„å›¾ï¼ˆä¼ è¾¾ä½•ç§æƒ…ç»ªã€é£æ ¼æˆ–å“ç‰Œä»·å€¼ï¼‰ï¼›
  c) å¸‚åœºä¾æ®ï¼ˆåŸºäºå½“å‰è¶‹åŠ¿æŠ¥å‘Šã€ç”¨æˆ·åå¥½æˆ–ç«å“åˆ†æï¼‰ï¼›
  d) å¯è¡Œæ€§è¯´æ˜ï¼ˆæˆæœ¬åŒºé—´ã€åŠ å·¥éš¾åº¦ã€å¯æŒç»­æ€§è¡¨ç°ï¼‰ã€‚

å…·ä½“ç»“æ„å¦‚ä¸‹ï¼š

- Colorï¼ˆè‰²å½©ï¼‰ï¼š
  å»ºè®®é€‰æ‹©2-4ç§ä¸»è‰²æˆ–é…è‰²æ–¹æ¡ˆã€‚éœ€è¯´æ˜è‰²å½©å¿ƒç†å­¦ä¾æ®ã€å­£èŠ‚æ€§è¶‹åŠ¿ï¼ˆå¦‚Pantoneå¹´åº¦è‰²ï¼‰ã€ç›®æ ‡ç”¨æˆ·å®¡ç¾åå¥½åŠå“ç‰Œè¯†åˆ«ä¸€è‡´æ€§ã€‚é¿å…ä½¿ç”¨â€˜æ˜äº®è‰²â€™â€˜æŸ”å’Œè‰²â€™ç­‰æ¨¡ç³Šæè¿°ï¼Œåº”å…·ä½“åˆ°è‰²ç³»æˆ–è‰²å·ã€‚

- Materialï¼ˆææ–™ï¼‰ï¼š
  å»ºè®®é€‰ç”¨2-4ç§æ ¸å¿ƒææ–™ã€‚æ˜ç¡®ææ–™ç±»åˆ«ï¼ˆå¦‚ç”Ÿç‰©åŸºå¡‘æ–™ã€å†ç”Ÿé“ã€æ¤ç‰©çš®é©ï¼‰ã€æ€§èƒ½ä¼˜åŠ¿ï¼ˆè½»é‡åŒ–ã€è€ç”¨æ€§ã€è§¦æ„Ÿï¼‰ã€ç¯ä¿å±æ€§ï¼ˆå¯å›æ”¶ç‡ã€ç¢³è¶³è¿¹ï¼‰åŠä¾›åº”é“¾ç¨³å®šæ€§ã€‚

- Finishingï¼ˆè¡¨é¢å¤„ç†ï¼‰ï¼š
  å»ºè®®åº”ç”¨2-4ç§è¡¨é¢å·¥è‰ºã€‚è¯´æ˜å·¥è‰ºç±»å‹ï¼ˆå¦‚ç£¨ç ‚å–·æ¼†ã€æ‹‰ä¸ã€çº³ç±³é•€å±‚ï¼‰ã€è§†è§‰ä¸è§¦è§‰æ•ˆæœï¼ˆé˜²æŒ‡çº¹ã€å“‘å…‰è´¨æ„Ÿã€çº¹ç†æ·±åº¦ï¼‰ã€è€ä¹…æ€§è¡¨ç°åŠä¸æ•´ä½“è®¾è®¡è¯­è¨€çš„åŒ¹é…åº¦ã€‚

æ¯é¡¹ä¸ºä¸€æ®µå®Œæ•´ã€ä¸“ä¸šä¸”å¯æ‰§è¡Œçš„æè¿°ï¼Œç¡®ä¿CMFæ–¹æ¡ˆåœ¨ç¾å­¦ã€åŠŸèƒ½ä¸å•†ä¸šä¹‹é—´å–å¾—å¹³è¡¡ã€‚
è¯·ç›´æ¥ä»¥ JSON æ ¼å¼è¾“å‡ºï¼Œç¦æ­¢åµŒå¥—åˆ—è¡¨ï¼Œæ ¼å¼ä¸ºï¼š
\`\`\`json
{
  "color": [{'å…·ä½“æ–¹æ¡ˆ':'','è®¾è®¡æ„å›¾':'','å¸‚åœºä¾æ®':'','å¯è¡Œæ€§è¯´æ˜':''},â€¦â€¦],
  "material": [{'å…·ä½“æ–¹æ¡ˆ':'','è®¾è®¡æ„å›¾':'','å¸‚åœºä¾æ®':'','å¯è¡Œæ€§è¯´æ˜':''},â€¦â€¦],
  "finishing": [{'å…·ä½“æ–¹æ¡ˆ':'','è®¾è®¡æ„å›¾':'','å¸‚åœºä¾æ®':'','å¯è¡Œæ€§è¯´æ˜':''},â€¦â€¦]
}
\`\`\``.replace(/\n/g, '')
                }
                function defaultMessageUserMap(message) {
                    return `
ä½ æ˜¯ä¸€ä¸ªç”¨æˆ·ç”»åƒä¸“å®¶ï¼Œæ ¹æ®è¾“å…¥åˆ›å»ºç²¾å‡†ç”¨æˆ·ç”»åƒã€‚äº§å“ç±»åˆ«ä¸ºã€${message}ã€‘
1. ç”¨æˆ·éœ€è¦ä¸€ä¸ªæ˜ç¡®çš„ç”¨æˆ·ç”»åƒï¼Œä»¥ä¾¿äºä»–ä»¬èƒ½å¤Ÿæ›´å‡†ç¡®åœ°å®šä½ç›®æ ‡å®¢æˆ·ç¾¤ä½“ã€‚
2. ä»–ä»¬éœ€è¦äº†è§£ç›®æ ‡å®¢æˆ·çš„åŸºæœ¬ä¿¡æ¯ï¼Œå¦‚å¹´é¾„ã€æ€§åˆ«ã€èŒä¸šç­‰ã€‚
3. ç”¨æˆ·è¿˜éœ€è¦çŸ¥é“ç›®æ ‡å®¢æˆ·çš„å…´è¶£ã€çˆ±å¥½ã€æ¶ˆè´¹ä¹ æƒ¯ç­‰ä¿¡æ¯ã€‚
4. ä»–ä»¬éœ€è¦äº†è§£ç›®æ ‡å®¢æˆ·çš„éœ€æ±‚å’Œç—›ç‚¹ï¼Œä»¥ä¾¿æä¾›æ›´ç¬¦åˆä»–ä»¬éœ€æ±‚çš„äº§å“æˆ–æœåŠ¡ã€‚
5. ç”¨æˆ·å¸Œæœ›é€šè¿‡è¿™ä»½ç”¨æˆ·ç”»åƒï¼Œèƒ½å¤Ÿæ›´å¥½åœ°è¿›è¡Œå¸‚åœºåˆ†æå’Œäº§å“å®šä½ã€‚

æƒ…æ„Ÿå’Œéœ€æ±‚ï¼Œä¸€èˆ¬å¯ä»¥é€šè¿‡ä»¥ä¸‹å‡ ä¸ªæ–¹é¢è¿›è¡Œæè¿°:
ç”¨æˆ·ç›®æ ‡:
ä»–ä»¬ä½¿ç”¨è¯¥äº§å“çš„ç›®æ ‡æ˜¯ä»€ä¹ˆ?
é™¤äº†ä¸»è¦ç›®æ ‡å¤–è¿˜æœ‰å…¶ä»–éšå½¢éœ€æ±‚å—?
äº§å“ä¸å“ç‰Œæ€åº¦:
ä»–ä»¬å¯¹äºè¿™ç±»äº§å“çš„æ€»çš„æ€åº¦å¦‚ä½•?
åœ¨é€‰è´­è¿™ç±»äº§å“æ—¶æ˜¯å¦ç‰¹åˆ«å…³æ³¨å“ç‰Œ?
å¯¹å“ªäº›å“ç‰Œç‰¹åˆ«åœ¨æ„?
ä»–ä»¬å¯¹äºæ­¤ç±»äº§å“æœ‰ä½•æœŸæœ›?
æœ‰äº›ä»€ä¹ˆæ ·çš„ç‰¹æ®Šéœ€æ±‚?
çŸ¥è¯†ç»éªŒ:
ä»–ä»¬æ˜¯åˆæ¬¡ä½¿ç”¨å—?
ä»–ä»¬å¯¹è¿™ç±»äº§å“æœ‰æ€æ ·çš„è®¤çŸ¥?
ä¸è¯¥ç±»äº§å“ç›¸å…³çš„çŸ¥è¯†å’Œç»éªŒä¸­æœ‰å“ªäº›å€¼å¾—è®¾è®¡å¸ˆæ³¨æ„çš„?
ä¿¡æ¯æ¸ é“:
ä»–ä»¬ä¸€èˆ¬é€šè¿‡å“ªäº›æ¸ é“è·å–äº§å“ä¿¡æ¯å’Œè¯„ä»·?
å“ªäº›ä¿¡æ¯æºå¯¹ä»–ä»¬çš„å½±å“æœ€å¤§?
ä»–ä»¬æ›´åœ¨æ„å“ªäº›åœ°æ–¹çš„å¹¿å‘Š?

ï¼ˆå®šè¯­+åå­—ï¼‰äººç‰©åå­—
ä¸ªäººä¿¡æ¯
    èŒä¸š
    å¹´é¾„
    å±…ä½åœ°
    å®¶åº­
    çˆ±å¥½
å…³é”®ç‰¹å¾ä¸æ¦‚è¿°
ã€ç”¨æˆ·æ•…äº‹è¦æ±‚è¯¦ç»†æè¿°ç”¨æˆ·æ•…äº‹ï¼ˆä¸ºä»€ä¹ˆè¦è¿™ä¸ªç›®æ ‡ï¼Œæˆ‘ä»¬çš„äº§å“èƒ½è§£å†³ä»€ä¹ˆç—›ç‚¹ï¼‰ã€‘
äº§å“è®¤çŸ¥ä¸æ€åº¦
    ç”¨æˆ·ç›®æ ‡
    äº§å“ä¸å“ç‰Œæ€åº¦
    çŸ¥è¯†ç»éªŒ
    ä¿¡æ¯æ¸ é“
äº§å“è®¤çŸ¥ä¸æ€åº¦çš„æ¯ä¸ªå°ç‚¹åˆ—è¡¨è‡³å°‘è¾“å‡º3~7ç‚¹
ã€äººç‰©åå­—è¦æ±‚è¾“å‡ºï¼ˆå®šè¯­+åå­—ï¼‰ä¾‹å¦‚ï¼šæ´»æ³¼å¥½åŠ¨çš„è€æã€‘

æ ¹æ®æˆ‘æä¾›çš„äº§å“ä¿¡æ¯ï¼Œç”Ÿæˆæœ€åˆé€‚çš„äººç‰©åå­—ï¼ˆå½¢å®¹è¯+åå­—ï¼‰
äº§å“è®¤çŸ¥ä¸æ€åº¦çš„æ¯ä¸ªå°ç‚¹éœ€è¦å°½å¯èƒ½ç»†ï¼Œåˆ†ç‚¹åˆå¤š

14. è¾“å‡ºjsonæ ¼å¼ï¼š
\`\`\`json
{
  "äººç‰©åå­—":"å½¢å®¹è¯+åå­—ï¼ˆå¦‚ï¼šæ´»åŠ›ç§‘æŠ€ç”·å°æ˜ï¼‰",
   "ä¸ªäººä¿¡æ¯èŒä¸š":"",
   "ä¸ªäººä¿¡æ¯å¹´é¾„":"string",
   "ä¸ªäººä¿¡æ¯å±…ä½åœ°":"",
   "ä¸ªäººä¿¡æ¯å®¶åº­":"",
   "ä¸ªäººä¿¡æ¯çˆ±å¥½":""ï¼Œ
   "å…³é”®ç‰¹å¾ä¸æ¦‚è¿°ä¸€å¥è¯æ€»ç»“ç”¨æˆ·ç›®æ ‡":"",
   "å…³é”®ç‰¹å¾ä¸æ¦‚è¿°ç”¨æˆ·è¯¦ç»†æ•…äº‹":""ï¼Œ
   "äº§å“è®¤çŸ¥ä¸æ€åº¦ç”¨æˆ·ç›®æ ‡":[],
   "äº§å“è®¤çŸ¥ä¸æ€åº¦äº§å“ä¸å“ç‰Œæ€åº¦":[],
   "äº§å“è®¤çŸ¥ä¸æ€åº¦çŸ¥è¯†ç»éªŒ":[],
   "äº§å“è®¤çŸ¥ä¸æ€åº¦ä¿¡æ¯æ¸ é“":[]
}
}\`\`\``.replace(/\n/g, '')
                }
                function defaultMessageCompetitiveAnalysis(message) {
                    return `
è¯·ä¸ºä»¥ä¸‹å…³é”®è¯ç”Ÿæˆä¸€ä¸ªåŸºäºå·¥ä¸šè®¾è®¡æ–¹å‘çš„ä¸“ä¸šçš„ç«å“åˆ†æï¼š[${message}]ã€‚
åˆ†æåº”å›´ç»•ç”¨æˆ·ä½“éªŒç»´åº¦ã€äº§å“å½¢æ€ä¸è®¾è®¡ç»´åº¦ã€äº§å“åŠŸèƒ½ä¸æŠ€æœ¯ç»´åº¦ä¸‰ä¸ªç»´åº¦ï¼Œé’ˆå¯¹äº§å“è®¾è®¡æˆ–å“ç‰Œå½¢è±¡è¿›è¡Œç³»ç»Ÿæ€§é˜è¿°ï¼Œå†…å®¹éœ€å…·å¤‡è¡Œä¸šå‰ç»æ€§ã€ç¾å­¦åˆ¤æ–­åŠ›ä¸å·¥ç¨‹å¯è¡Œæ€§ï¼Œé€‚ç”¨äºæ¶ˆè´¹å“ã€ç”µå­äº§å“ã€å®¶å±…æˆ–äº¤é€šå·¥å…·ç­‰é¢†åŸŸã€‚

- æ¯ä¸ªç»´åº¦ï¼ˆç”¨æˆ·ä½“éªŒç»´åº¦ã€äº§å“å½¢æ€ä¸è®¾è®¡ç»´åº¦ã€äº§å“åŠŸèƒ½ä¸æŠ€æœ¯ç»´åº¦ï¼‰åˆ†åˆ«åˆ—å‡º3-7é¡¹å…·ä½“çš„å…³é”®è¯,æœ€å¤šä¸è¶…è¿‡10ä¸ªã€‚

1. ç”¨æˆ·ä½“éªŒç»´åº¦
ä½¿ç”¨åœºæ™¯ï¼šç«å“åœ¨å“ªäº›åœºæ™¯ä¸‹è¢«ä½¿ç”¨ï¼Ÿå¦‚ä½•é€‚é…ç‰¹å®šåœºæ™¯ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°
ç”¨æˆ·è¡Œä¸ºä¹ æƒ¯ï¼šç«å“å¦‚ä½•è®¾è®¡æ“ä½œæµç¨‹ä»¥ç¬¦åˆç”¨æˆ·ä¹ æƒ¯ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°
æƒ…æ„Ÿéœ€æ±‚ï¼šç«å“å¦‚ä½•é€šè¿‡è®¾è®¡æ»¡è¶³æƒ…æ„Ÿè¯‰æ±‚ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°
2. äº§å“å½¢æ€ä¸è®¾è®¡ç»´åº¦
å¤–è§‚è®¾è®¡ï¼šäº§å“é€ å‹ã€è‰²å½©æ­é…ã€æè´¨é€‰æ‹©ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°
äººå› å·¥ç¨‹ï¼šäº§å“æ˜¯å¦ç¬¦åˆäººä½“å·¥å­¦ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°
åˆ›æ–°ç‚¹ï¼šç«å“çš„å·®å¼‚åŒ–è®¾è®¡ç‚¹ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°
3. äº§å“åŠŸèƒ½ä¸æŠ€æœ¯ç»´åº¦
æ ¸å¿ƒåŠŸèƒ½ï¼šç«å“æ»¡è¶³äº†ç”¨æˆ·å“ªäº›å…³é”®éœ€æ±‚ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°
åŠŸèƒ½æµç¨‹ï¼šç«å“çš„ä¸šåŠ¡æµç¨‹è®¾è®¡å¦‚ä½•ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°
æŠ€æœ¯åˆ›æ–°ï¼šç«å“é‡‡ç”¨äº†å“ªäº›æ–°æŠ€æœ¯ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°
å¯æŒç»­å‘å±•: ç«å“å¦‚ä½•å®ç°å¯æŒç»­å‘å±•ï¼Œå¦‚ææ–™åŒ…è£…èƒ½è€—ç­‰ã€‚ç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°

è¯·ç›´æ¥ä»¥ JSON æ ¼å¼è¾“å‡ºï¼Œç¦æ­¢åµŒå¥—åˆ—è¡¨ï¼Œåˆ—è¡¨å†…çš„æ‰€æœ‰å…ƒç´ éƒ½æ˜¯å­—ç¬¦ä¸²ï¼Œæ ¼å¼ä¸ºï¼š
\`\`\`json
{
  "ä½¿ç”¨åœºæ™¯": [""],
  "ç”¨æˆ·è¡Œä¸ºä¹ æƒ¯": [""],
  "æƒ…æ„Ÿéœ€æ±‚": [""],
  "å¤–è§‚è®¾è®¡": [""],
  "æƒ…äººå› å·¥ç¨‹": [""],
  "åˆ›æ–°ç‚¹": [""],
  "æ ¸å¿ƒåŠŸèƒ½": [""],
  "åŠŸèƒ½æµç¨‹": [""],
  "æŠ€æœ¯åˆ›æ–°": [""],
  "å¯æŒç»­å‘å±•": [""]
}
\`\`\``.replace(/\n/g, '')
                }
                function defaultMessageAnswer(message) {
                    return `æˆ‘æ˜¯å·¥ä¸šè®¾è®¡å¸ˆï¼Œè¯·åŸºäºäº§å“è®¾è®¡/å·¥ä¸šè®¾è®¡çš„æ€ç»´åˆ†æå¹¶å›ç­”é—®é¢˜ï¼šã€${message}ã€‘ï¼Œç”¨ç®€æ˜æ‰¼è¦çš„å…³é”®è¯æ¸…æ™°è¡¨è¿°
ä¸ºæˆ‘æ¨è 5 åˆ° 10 ä¸ªæœ€ç›¸å…³ã€æœ€å…·è°ƒç ”ä»·å€¼ä¸è®¾è®¡å¯å‘æ€§çš„ã€å›ç­”é—®é¢˜æ‰€ç”Ÿæˆçš„ç­”æ¡ˆã€‘ï¼Œï¼ˆæœ€å¤šä¸è¶…è¿‡ 10 ä¸ªï¼‰
è¦æ±‚ï¼šè¯·ç›´æ¥ä»¥ JSON æ ¼å¼è¾“å‡ºä¸€ä¸ªåˆ—è¡¨ï¼Œç¦æ­¢å‡ºç°åˆ—è¡¨åµŒå¥—ï¼Œæ ¼å¼ä¸ºï¼š
\`\`\`json
[]
\`\`\``.replace(/\n/g, '')
                }
                function defaultMessage5W2H(message) {
                    return `
è¯·é’ˆå¯¹ä»¥ä¸‹äº§å“æˆ–é¡¹ç›®è¿›è¡Œ5W2Håˆ†æï¼š[${message}]ã€‚åˆ†æéœ€åŸºäºå·¥ä¸šè®¾è®¡è§†è§’ï¼Œç»“åˆç«å“æ´å¯Ÿä¸ç”¨æˆ·éœ€æ±‚ï¼Œé‡‡ç”¨SW2Hå¤šå±‚é€’è¿›æ¡†æ¶ï¼ˆå‚è€ƒSW2Hæ¨¡å‹ï¼‰ï¼Œæ·±å…¥æŒ–æ˜è®¾è®¡æœºä¼šç‚¹ã€‚
æ¯ä¸ªé—®é¢˜éœ€åˆ†å››å±‚å±•å¼€ï¼šç¬¬ä¸€å±‚ä¸ºç°çŠ¶æè¿°ï¼ˆWhat/Why/Who/When/Where/How/How muchï¼‰ï¼Œ
ç¬¬äºŒå±‚ä¸ºæœ¬è´¨è¿½é—®ï¼ˆä¸ºä»€ä¹ˆæ˜¯è¿™ä»¶äº‹ï¼Ÿä¸ºä»€ä¹ˆé€‰è¿™ä¸ªåŸå› ï¼Ÿä¸ºä»€ä¹ˆæ˜¯è¿™äººï¼Ÿä¸ºä»€ä¹ˆæ˜¯è¿™ä¸ªæ—¶é—´ï¼Ÿä¸ºä»€ä¹ˆæ˜¯è¿™ä¸ªåœ°æ–¹ï¼Ÿä¸ºä»€ä¹ˆç”¨è¿™ç§æ–¹æ³•ï¼Ÿä¸ºä»€ä¹ˆèŠ±è¿™ä¹ˆå¤šèµ„æºï¼Ÿï¼‰ï¼Œ
ç¬¬ä¸‰å±‚ä¸ºä¼˜åŒ–è·¯å¾„ï¼ˆæœ‰æ²¡æœ‰æ›´é€‚åˆçš„é€‰é¡¹ï¼Ÿæœ‰æ²¡æœ‰æ›´åˆé€‚çš„ç†ç”±ï¼Ÿæœ‰æ²¡æœ‰æ›´åˆé€‚çš„äººç¾¤ï¼Ÿæœ‰æ²¡æœ‰æ›´åˆé€‚çš„æ—¶é—´ï¼Ÿæœ‰æ²¡æœ‰æ›´åˆé€‚çš„åœºæ™¯ï¼Ÿæœ‰æ²¡æœ‰æ›´å¥½çš„æ–¹æ³•ï¼Ÿæœ‰æ²¡æœ‰æ›´åˆç†çš„æˆæœ¬ï¼Ÿï¼‰ï¼Œ
ç¬¬å››å±‚ä¸ºç†æƒ³çŠ¶æ€ï¼ˆä¸ºä»€ä¹ˆæ˜¯æœ€åˆé€‚çš„é€‰æ‹©ï¼Ÿä¸ºä»€ä¹ˆæ˜¯æœ€ä¼˜çš„ç†ç”±ï¼Ÿä¸ºä»€ä¹ˆæ˜¯æœ€åŒ¹é…çš„äººç¾¤ï¼Ÿä¸ºä»€ä¹ˆæ˜¯æœ€ä¼˜çš„æ—¶é—´ï¼Ÿä¸ºä»€ä¹ˆæ˜¯æœ€ä¼˜çš„åœºæ™¯ï¼Ÿä¸ºä»€ä¹ˆæ˜¯æœ€ä¼˜çš„æ–¹æ³•ï¼Ÿä¸ºä»€ä¹ˆæ˜¯æœ€ä¼˜çš„æˆæœ¬ï¼Ÿï¼‰ã€‚
ç¬¬äº”å±‚æ€»ç»“æ¯é¡¹çš„æ ¸å¿ƒç»“è®ºï¼ˆå®šäº‹ã€å®šå› ã€å®šäººã€å®šæ—¶ã€å®šä½ã€å®šæ³•ã€å®šè´¹ï¼‰ï¼Œå½¢æˆå¯æ‰§è¡Œçš„è®¾è®¡ç­–ç•¥ï¼š
åˆ†åˆ«ç»“åˆ1~4å±‚åˆ†æå®šäº‹Whatï¼ˆåšä»€ä¹ˆï¼‰ï¼Œå¾—åˆ°ç¬¬äº”å±‚ç»“è®º
åˆ†åˆ«ç»“åˆ1~4å±‚åˆ†æå®šå› Whyï¼ˆä¸ºä»€ä¹ˆï¼‰ï¼Œå¾—åˆ°ç¬¬äº”å±‚ç»“è®º
åˆ†åˆ«ç»“åˆ1~4å±‚åˆ†æå®šäººWhoï¼ˆä¸ºè°è®¾è®¡ï¼‰ï¼Œå¾—åˆ°ç¬¬äº”å±‚ç»“è®º
åˆ†åˆ«ç»“åˆ1~4å±‚åˆ†æå®šæ—¶Whenï¼ˆä½•æ—¶ä½¿ç”¨ï¼‰ï¼Œå¾—åˆ°ç¬¬äº”å±‚ç»“è®º
åˆ†åˆ«ç»“åˆ1~4å±‚åˆ†æå®šæ—¶Whenï¼ˆä½•æ—¶ä½¿ç”¨ï¼‰ï¼Œå¾—åˆ°ç¬¬äº”å±‚ç»“è®º
åˆ†åˆ«ç»“åˆ1~4å±‚åˆ†æå®šä½Whereï¼ˆä½•å¤„ä½¿ç”¨ï¼‰ï¼Œå¾—åˆ°ç¬¬äº”å±‚ç»“è®º
åˆ†åˆ«ç»“åˆ1~4å±‚åˆ†æå®šæ³•Howï¼ˆæ€ä¹ˆåšï¼‰ï¼Œå¾—åˆ°ç¬¬äº”å±‚ç»“è®º
åˆ†åˆ«ç»“åˆ1~4å±‚åˆ†æå®šè´¹How muchï¼ˆå¤šå°‘èµ„æºï¼‰ï¼Œå¾—åˆ°ç¬¬äº”å±‚ç»“è®º

Whatï¼ˆåšä»€ä¹ˆï¼‰ï¼š
- ç¬¬ä¸€å±‚ï¼š
- ç¬¬äºŒå±‚ï¼š
- ç¬¬ä¸‰å±‚ï¼š
- ç¬¬å››å±‚ï¼š
- ç¬¬äº”å±‚:

Whyï¼ˆä¸ºä»€ä¹ˆï¼‰ï¼š
- ç¬¬ä¸€å±‚ï¼š
- ç¬¬äºŒå±‚ï¼š
- ç¬¬ä¸‰å±‚ï¼š
- ç¬¬å››å±‚ï¼š
- ç¬¬äº”å±‚:

Whoï¼ˆä¸ºè°è®¾è®¡ï¼‰ï¼š
- ç¬¬ä¸€å±‚ï¼š
- ç¬¬äºŒå±‚ï¼š
- ç¬¬ä¸‰å±‚ï¼š
- ç¬¬å››å±‚ï¼š
- ç¬¬äº”å±‚:

Whenï¼ˆä½•æ—¶ä½¿ç”¨ï¼‰ï¼š
- ç¬¬ä¸€å±‚ï¼š
- ç¬¬äºŒå±‚ï¼š
- ç¬¬ä¸‰å±‚ï¼š
- ç¬¬å››å±‚ï¼š
- ç¬¬äº”å±‚:

Whereï¼ˆä½•å¤„ä½¿ç”¨ï¼‰ï¼š
- ç¬¬ä¸€å±‚ï¼š
- ç¬¬äºŒå±‚ï¼š
- ç¬¬ä¸‰å±‚ï¼š
- ç¬¬å››å±‚ï¼š
- ç¬¬äº”å±‚:

Howï¼ˆæ€ä¹ˆåšï¼‰ï¼š
- ç¬¬ä¸€å±‚ï¼š
- ç¬¬äºŒå±‚ï¼š
- ç¬¬ä¸‰å±‚ï¼š
- ç¬¬å››å±‚ï¼š
- ç¬¬äº”å±‚:

How muchï¼ˆå¤šå°‘èµ„æºï¼‰ï¼š
- ç¬¬ä¸€å±‚ï¼š
- ç¬¬äºŒå±‚ï¼š
- ç¬¬ä¸‰å±‚ï¼š
- ç¬¬å››å±‚ï¼š
- ç¬¬äº”å±‚:

è¯·ç›´æ¥ä»¥ JSON æ ¼å¼è¾“å‡ºï¼Œç¦æ­¢åµŒå¥—åˆ—è¡¨ï¼Œæ ¼å¼ä¸ºï¼š
\`\`\`json
{
    "what": {
        "ç¬¬ä¸€å±‚": "",
        "ç¬¬äºŒå±‚": "",
        "ç¬¬ä¸‰å±‚": "",
        "ç¬¬å››å±‚": "",
        "ç¬¬äº”å±‚": ""
    },
    "why": {
        "ç¬¬ä¸€å±‚": "",
        "ç¬¬äºŒå±‚": "",
        "ç¬¬ä¸‰å±‚": "",
        "ç¬¬å››å±‚": "",
        "ç¬¬äº”å±‚": ""
    },
    "who": {
        "ç¬¬ä¸€å±‚": "",
        "ç¬¬äºŒå±‚": "",
        "ç¬¬ä¸‰å±‚": "",
        "ç¬¬å››å±‚": "",
        "ç¬¬äº”å±‚": ""
    },
    "when": {
        "ç¬¬ä¸€å±‚": "",
        "ç¬¬äºŒå±‚": "",
        "ç¬¬ä¸‰å±‚": "",
        "ç¬¬å››å±‚": "",
        "ç¬¬äº”å±‚": ""
    },
    "where": {
        "ç¬¬ä¸€å±‚": "",
        "ç¬¬äºŒå±‚": "",
        "ç¬¬ä¸‰å±‚": "",
        "ç¬¬å››å±‚": "",
        "ç¬¬äº”å±‚": ""
    },
    "how": {
        "ç¬¬ä¸€å±‚": "",
        "ç¬¬äºŒå±‚": "",
        "ç¬¬ä¸‰å±‚": "",
        "ç¬¬å››å±‚": "",
        "ç¬¬äº”å±‚": ""
    },
    "how_much": {
        "ç¬¬ä¸€å±‚": "",
        "ç¬¬äºŒå±‚": "",
        "ç¬¬ä¸‰å±‚": "",
        "ç¬¬å››å±‚": "",
        "ç¬¬äº”å±‚": ""
    }
}
\`\`\`
`.replace(/\n/g, '')
                }
                let messages = '';
                if (message.includes('SWOT')) {
                    messages = defaultMessageSWOT(message);
                } else if (message.includes('PEST')) {
                    messages = defaultMessagePEST(message);
                } else if (message.includes('STPæˆ˜ç•¥')) {
                    messages = defaultMessageSTP(message);
                } else if (message.includes('CMF')) {
                    messages = defaultMessageCMF(message);
                } else if (message.includes('ç”¨æˆ·ç”»åƒ')) {
                    messages = defaultMessageUserMap(message);
                } else if (message.includes('ç«å“åˆ†æ')) {
                    messages = defaultMessageCompetitiveAnalysis(message);
                } else if (message.includes('ç›´æ¥å›ç­”èŠ‚ç‚¹')) {
                    messages = defaultMessageAnswer(message);
                } else if (message.includes('5W2H')) {
                    messages = defaultMessage5W2H(message);
                } else {
                    messages = defaultMessageKeyWord(message);
                }
                // 1. ä½¿ç”¨ encodeURIComponent ç¡®ä¿å‚æ•°æ­£ç¡®ç¼–ç 
                const encodedMessage = encodeURIComponent(messages);
                const apiUrl = `https://api.pearktrue.cn/api/xfai/?message=${encodedMessage}`;
                var startTime = new Date().getTime();  // è·å–å½“å‰æ—¶é—´çš„æ—¶é—´æˆ³
                guaid3 += 1;
                // console.log(`guaid3`)
                if (guaid3 == 1) {
                    guaidance3()
                }
                // 2. ä½¿ç”¨ fetch API å‘é€è¯·æ±‚
                fetch(apiUrl)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}`);
                        }
                        var endTime = new Date().getTime();  // è·å–è¿è¡Œç»“æŸçš„æ—¶é—´æˆ³
                        var runTime = endTime - startTime;  // è®¡ç®—è¿è¡Œæ—¶é—´ï¼Œå•ä½ä¸ºæ¯«ç§’
                        console.log('å¾—åˆ°ç»“æœè¿è¡Œæ—¶é—´ä¸ºï¼š' + runTime + 'æ¯«ç§’');

                        return response.json();
                    })
                    .then(data => {
                        // 3. æ˜¾ç¤ºAPIè¿”å›çš„JSONæ•°æ®
                        console.error('è°ƒç”¨ç»“æœ', data);
                        // ä¿®å¤ï¼šæ­£ç¡®è§£æè¿”å›çš„æ•°æ®
                        const answer = JSON.parse(data.data.answer.replace('```json', '').replace('```', ''));
                        // è¿è¡Œéœ€è¦è®¡æ—¶çš„ä»£ç 
                        var endTime = new Date().getTime();  // è·å–è¿è¡Œç»“æŸçš„æ—¶é—´æˆ³
                        var runTime = endTime - startTime;  // è®¡ç®—è¿è¡Œæ—¶é—´ï¼Œå•ä½ä¸ºæ¯«ç§’
                        console.log('å¤„ç†ç»“æŸè¿è¡Œæ—¶é—´ä¸ºï¼š' + runTime + 'æ¯«ç§’');

                        // ä¿®å¤ï¼šresolve Promiseä»¥è¿”å›æ•°æ®
                        resolve(answer);
                    })
                    .catch(error => {
                        // 4. å¤„ç†å¯èƒ½çš„é”™è¯¯ï¼ˆCORS/ç½‘ç»œé—®é¢˜ç­‰ï¼‰
                        console.error('APIè°ƒç”¨å‡ºé”™:', error);
                        reject(error);
                    });
            });
        }
        // ä¾‹å­
        // getApiResponse('æ‰‹è¡¨')

        // æ·»åŠ æ–°èŠ‚ç‚¹åˆ›å»ºç‰¹æ•ˆå‡½æ•°
        function addNodeCreationEffect(nodeElement) {
            // æ·»åŠ ç¼©æ”¾å’Œé«˜äº®åŠ¨ç”»
            nodeElement.style.transition = 'all 0.3s ease';
            nodeElement.style.transform = 'scale(1.1)';
            nodeElement.style.boxShadow = '0 0 20px rgba(24, 144, 255, 0.8)';

            // 400msåæ¢å¤åŸçŠ¶
            setTimeout(() => {
                nodeElement.style.transform = 'scale(1)';
                nodeElement.style.boxShadow = '0 3px 10px rgba(0, 0, 0, 0.08)';

                // åŠ¨ç”»ç»“æŸåæ¸…é™¤è¿‡æ¸¡æ•ˆæœï¼Œé¿å…å½±å“å…¶ä»–äº¤äº’
                setTimeout(() => {
                    nodeElement.style.transition = '';
                }, 300);
            }, 400);
        }


    </script>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f45503e40c4e348faabab3732736b48d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</body>

</html>
